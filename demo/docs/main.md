# 基本方向

目标是基于 zod 实现基于类型的 UI 映射，并且在此基础上提供丰富的各个层面的扩展性 API 以供用户使用，封装。

## 基本思想

对于 UI 来说，分为俩种类型的元素

* Viewer：展示型元素，如文本、图片、视频等
* Controller：控制型元素，如按钮、输入框等

从组件设计角度分析，上面俩种类型的元素的本质性区别为对数据的可控性，
即 Viewer 只能展示数据，而 Controller 可以控制数据。

#### Viewer

#### Controller

从类型与值的关系上来说，我们以是否多元化来对其进行一个简单的分类

* Monad: 单类型、单变量
* Complex: 多类型、单变量
* Multiple: 多类型、多变量

#### Monad

#### Complex

#### Multiple

## 关于框架

为了方便实现对多种前端框架的支持，比如在通用逻辑上的复用、基本样式上的重用、以及插件管理机制上的统一，可以将部分逻辑抽象为独立的模块进行维护。

### 插件注册管理

对于插件的注册与管理实际上在多种框架下并没有太大的差别，而这段逻辑不断在多个框架下进行重复开发是不值得的。

在抽象的基础上，同时需要考虑对多种框架的兼容，以及用户在使用时候的 tree shaking 需求

### 通用的类型系统

对于类型系统来说，其实现的本质是对数据的描述，因此对于不同的框架来说，其实现的本质是一致的。

基于最基础的组件来说，都是对一个函数进行 props 输入，再得到框架预期的输出，在通用层面上我们对框架预期的输出并不关心，这个由各个框架的兼容系统负责并处理。

### 数据同步

每一个前端框架为了实现自己对 D-V 模型的响应式设计，都有着自己的数据状态系统。
而我们的部分逻辑独立于其系统外部进行管理，部分耦合于系统内部进行管理。
于是可以将独立于各个系统外部的部分抽象出来，以便于在不同的框架下进行复用。
然后再经过不同的适配器，将其转换为各个框架的数据系统所能识别的数据。
而部分耦合于系统内部的状态，这部分便是各个框架的兼容系统所需要处理的部分。

用代码对上面的行为进行描述，便是：
```typescript
useEffect(() => {
  return zodui.onCompUpate(newComp => this.comp = newComp)
}, [])
```
