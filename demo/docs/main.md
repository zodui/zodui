# 基本方向

目标是基于 zod 实现基于类型的 UI 映射，并且在此基础上提供丰富的各个层面的扩展性 API 以供用户使用，封装。

## 基本思想

我们可以将用户所能操作的基本元素分为俩种类型：

* Viewer：展示型元素，如文本、图片、视频等

* Controller：控制型元素，如按钮、输入框等

从组件设计角度分析，上面俩种类型的元素的本质性区别为对数据的可控性，
即 Viewer 只能展示数据，而 Controller 可以控制数据。

当我们划分了基本元素之后我们需要对其进行组合，从而形成一个完整的 UI 组件，在这里我们引入一个概念 `Structure`。

它会对基本元素进行编排展示控制，从而形成一个完整的交互逻辑。例如常见交互模式有：

* 列表构型
* 表格构型
* Tabs 构型
* 分步构型

### Viewer

### Controller

对于一个控制器来说，他由以下几个部分组成

* 数据的展示
  
  数据可以根据类型、限制、模式产生各种不同形式展现，并且通过对展示元素的互动形成对值的控制。

* 操作的限制

  通过操作进行限制，比如当一个选项是必填项时，在需要的时候抛出相应的错误，或者当一个数字类型有最大值的时候，操作可能超过限制的时候禁用对应的操作。

* 数据的更新

  当数据被控制器内部的逻辑进行相应计算后，再经过校验逻辑后将正确的数据提供到外部层级通知其进行对应的更新。

* 数据的校验

  就如上面所说的，对数据出口按照设定的逻辑进行校验，并且通过尽量统一的形式进行错误的渲染或者抛出。

### SubController

在内部我们对 Controller 进行了一些细粒度对划分，基本原则是：从类型与值我们以是否多元化来对其进行一个简单的分类。
并且提供了一些针对性质的 Api 以便于用户在使用时候进行扩展。

* Monad: 单类型、单变量
* Complex: 多类型、单变量
* Multiple: 多类型、多变量

#### Monad

#### Complex

#### Multiple

## 关于框架

为了方便实现对多种前端框架的支持，比如在通用逻辑上的复用、基本样式上的重用、以及插件管理机制上的统一，可以将部分逻辑抽象为独立的模块进行维护。

### 插件注册管理

对于插件的注册与管理实际上在多种框架下并没有太大的差别，而这段逻辑不断在多个框架下进行重复开发是不值得的。

在抽象的基础上，同时需要考虑对多种框架的兼容，以及用户在使用时候的 tree shaking 需求

### 通用的类型系统

对于类型系统来说，其实现的本质是对数据的描述，因此对于不同的框架来说，其实现的本质是一致的。

基于最基础的组件来说，都是对一个函数进行 props 输入，再得到框架预期的输出，在通用层面上我们对框架预期的输出并不关心，这个由各个框架的兼容系统负责并处理。

### 数据同步

每一个前端框架为了实现自己对 D-V 模型的响应式设计，都有着自己的数据状态系统。
而我们的部分逻辑独立于其系统外部进行管理，部分耦合于系统内部进行管理。
于是可以将独立于各个系统外部的部分抽象出来，以便于在不同的框架下进行复用。
然后再经过不同的适配器，将其转换为各个框架的数据系统所能识别的数据。
而部分耦合于系统内部的状态，这部分便是各个框架的兼容系统所需要处理的部分。

用代码对上面的行为进行描述，便是：
```typescript
useEffect(() => {
  return zodui.onCompUpate(newComp => this.comp = newComp)
}, [])
```
