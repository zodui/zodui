<!doctype html><html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/><link rel="alternate icon" class="js-site-favicon" type="image/png" href="/zodui/favicon.png"><link rel="icon" class="js-site-favicon" type="image/svg+xml" href="/zodui/favicon.svg"><title>Zod UI - Playground</title><link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons"><style data-name="default">body{display:flex;margin:0;padding-top:60px;font-family:'Segoe UI',Tahoma,Geneva,Verdana,sans-serif}div.main{display:flex;width:100%}</style><style data-name="message">div.message{position:fixed;top:10px;left:50%;transform:translate(-50%,-150%);padding:1em;background-color:#fff;border:1px solid var(--br-cr);border-radius:5px;box-shadow:0 0 10px rgba(0,0,0,.2);opacity:0;transition:.3s ease-in-out}div.message.show{opacity:1;transform:translateX(-50%)}</style><template id="message-template"><div class="message">{{content}}</div></template><style data-name="popper">html[theme-mode=dark] .popper{background-color:#3d3d3d;color:#fff;box-shadow:0 0 4px rgba(255,255,255,.1)}html[theme-mode=dark] .popper .menu-item{border-color:#4d4d4d}html[theme-mode=dark] .popper .menu-item:hover{background-color:#2d2d2d}.popper{background-color:#fff;color:#000;font-weight:700;padding:4px 8px;font-size:13px;border-radius:4px;opacity:0;pointer-events:none;box-shadow:0 0 8px rgba(0,0,0,.2);transition:.3s ease-in-out}.popper[data-show]{opacity:1;pointer-events:auto}.popper[data-popper-reference-hidden]{visibility:hidden;pointer-events:none}.popper>.arrow,.popper>.arrow::before{position:absolute;width:8px;height:8px;background:inherit}.popper>.arrow{visibility:hidden}.popper>.arrow::before{visibility:visible;content:'';transform:rotate(45deg)}.popper[data-popper-placement^=top]>.arrow{bottom:-4px}.popper[data-popper-placement^=bottom]>.arrow{top:-4px}.popper[data-popper-placement^=left]>.arrow{right:-4px}.popper[data-popper-placement^=right]>.arrow{left:-4px}.popper .menu-item{padding:10px 20px;border-bottom:1px solid #d3d3d3;cursor:pointer;transition:.3s}.popper .menu-item:last-child{border-bottom:none}.popper .menu-item:hover{background-color:#f0f0f0}</style><template id="popper"><div class="popper"><div class="arrow" data-popper-arrow></div>{{content}}</div></template><script>var require = { paths: { vs: './monaco/min/vs' } }</script><link rel="stylesheet" data-name="vs/editor/editor.main" href="/zodui/monaco/min/vs/editor/editor.main.css"><script src="/zodui/monaco/min/vs/loader.js"></script><script src="/zodui/monaco/min/vs/editor/editor.main.nls.js"></script><script src="/zodui/monaco/min/vs/editor/editor.main.js"></script><script>const MONACO_DTS_FILES = [{"content":"import type { TypeOf, ZodType } from \".\";\nimport { Primitive } from \"./helpers/typeAliases\";\nimport { util, ZodParsedType } from \"./helpers/util\";\ndeclare type allKeys<T> = T extends any ? keyof T : never;\nexport declare type inferFlattenedErrors<T extends ZodType<any, any, any>, U = string> = typeToFlattenedError<TypeOf<T>, U>;\nexport declare type typeToFlattenedError<T, U = string> = {\n    formErrors: U[];\n    fieldErrors: {\n        [P in allKeys<T>]?: U[];\n    };\n};\nexport declare const ZodIssueCode: {\n    invalid_type: \"invalid_type\";\n    invalid_literal: \"invalid_literal\";\n    custom: \"custom\";\n    invalid_union: \"invalid_union\";\n    invalid_union_discriminator: \"invalid_union_discriminator\";\n    invalid_enum_value: \"invalid_enum_value\";\n    unrecognized_keys: \"unrecognized_keys\";\n    invalid_arguments: \"invalid_arguments\";\n    invalid_return_type: \"invalid_return_type\";\n    invalid_date: \"invalid_date\";\n    invalid_string: \"invalid_string\";\n    too_small: \"too_small\";\n    too_big: \"too_big\";\n    invalid_intersection_types: \"invalid_intersection_types\";\n    not_multiple_of: \"not_multiple_of\";\n    not_finite: \"not_finite\";\n};\nexport declare type ZodIssueCode = keyof typeof ZodIssueCode;\nexport declare type ZodIssueBase = {\n    path: (string | number)[];\n    message?: string;\n};\nexport interface ZodInvalidTypeIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_type;\n    expected: ZodParsedType;\n    received: ZodParsedType;\n}\nexport interface ZodInvalidLiteralIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_literal;\n    expected: unknown;\n    received: unknown;\n}\nexport interface ZodUnrecognizedKeysIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.unrecognized_keys;\n    keys: string[];\n}\nexport interface ZodInvalidUnionIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_union;\n    unionErrors: ZodError[];\n}\nexport interface ZodInvalidUnionDiscriminatorIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_union_discriminator;\n    options: Primitive[];\n}\nexport interface ZodInvalidEnumValueIssue extends ZodIssueBase {\n    received: string | number;\n    code: typeof ZodIssueCode.invalid_enum_value;\n    options: (string | number)[];\n}\nexport interface ZodInvalidArgumentsIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_arguments;\n    argumentsError: ZodError;\n}\nexport interface ZodInvalidReturnTypeIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_return_type;\n    returnTypeError: ZodError;\n}\nexport interface ZodInvalidDateIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_date;\n}\nexport declare type StringValidation = \"email\" | \"url\" | \"emoji\" | \"uuid\" | \"regex\" | \"cuid\" | \"cuid2\" | \"ulid\" | \"datetime\" | \"ip\" | {\n    includes: string;\n    position?: number;\n} | {\n    startsWith: string;\n} | {\n    endsWith: string;\n};\nexport interface ZodInvalidStringIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_string;\n    validation: StringValidation;\n}\nexport interface ZodTooSmallIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.too_small;\n    minimum: number | bigint;\n    inclusive: boolean;\n    exact?: boolean;\n    type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\nexport interface ZodTooBigIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.too_big;\n    maximum: number | bigint;\n    inclusive: boolean;\n    exact?: boolean;\n    type: \"array\" | \"string\" | \"number\" | \"set\" | \"date\" | \"bigint\";\n}\nexport interface ZodInvalidIntersectionTypesIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.invalid_intersection_types;\n}\nexport interface ZodNotMultipleOfIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.not_multiple_of;\n    multipleOf: number | bigint;\n}\nexport interface ZodNotFiniteIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.not_finite;\n}\nexport interface ZodCustomIssue extends ZodIssueBase {\n    code: typeof ZodIssueCode.custom;\n    params?: {\n        [k: string]: any;\n    };\n}\nexport declare type DenormalizedError = {\n    [k: string]: DenormalizedError | string[];\n};\nexport declare type ZodIssueOptionalMessage = ZodInvalidTypeIssue | ZodInvalidLiteralIssue | ZodUnrecognizedKeysIssue | ZodInvalidUnionIssue | ZodInvalidUnionDiscriminatorIssue | ZodInvalidEnumValueIssue | ZodInvalidArgumentsIssue | ZodInvalidReturnTypeIssue | ZodInvalidDateIssue | ZodInvalidStringIssue | ZodTooSmallIssue | ZodTooBigIssue | ZodInvalidIntersectionTypesIssue | ZodNotMultipleOfIssue | ZodNotFiniteIssue | ZodCustomIssue;\nexport declare type ZodIssue = ZodIssueOptionalMessage & {\n    fatal?: boolean;\n    message: string;\n};\nexport declare const quotelessJson: (obj: any) => string;\ndeclare type recursiveZodFormattedError<T> = T extends [any, ...any[]] ? {\n    [K in keyof T]?: ZodFormattedError<T[K]>;\n} : T extends any[] ? {\n    [k: number]: ZodFormattedError<T[number]>;\n} : T extends object ? {\n    [K in keyof T]?: ZodFormattedError<T[K]>;\n} : unknown;\nexport declare type ZodFormattedError<T, U = string> = {\n    _errors: U[];\n} & recursiveZodFormattedError<NonNullable<T>>;\nexport declare type inferFormattedError<T extends ZodType<any, any, any>, U = string> = ZodFormattedError<TypeOf<T>, U>;\nexport declare class ZodError<T = any> extends Error {\n    issues: ZodIssue[];\n    get errors(): ZodIssue[];\n    constructor(issues: ZodIssue[]);\n    format(): ZodFormattedError<T>;\n    format<U>(mapper: (issue: ZodIssue) => U): ZodFormattedError<T, U>;\n    static create: (issues: ZodIssue[]) => ZodError<any>;\n    toString(): string;\n    get message(): string;\n    get isEmpty(): boolean;\n    addIssue: (sub: ZodIssue) => void;\n    addIssues: (subs?: ZodIssue[]) => void;\n    flatten(): typeToFlattenedError<T>;\n    flatten<U>(mapper?: (issue: ZodIssue) => U): typeToFlattenedError<T, U>;\n    get formErrors(): typeToFlattenedError<T, string>;\n}\ndeclare type stripPath<T extends object> = T extends any ? util.OmitKeys<T, \"path\"> : never;\nexport declare type IssueData = stripPath<ZodIssueOptionalMessage> & {\n    path?: (string | number)[];\n    fatal?: boolean;\n};\nexport declare type ErrorMapCtx = {\n    defaultError: string;\n    data: any;\n};\nexport declare type ZodErrorMap = (issue: ZodIssueOptionalMessage, _ctx: ErrorMapCtx) => {\n    message: string;\n};\nexport {};\n","filePath":"file:///node_modules/@types/zod/ZodError.d.ts"},{"content":"export declare class Mocker {\n    pick: (...args: any[]) => any;\n    get string(): string;\n    get number(): number;\n    get bigint(): bigint;\n    get boolean(): boolean;\n    get date(): Date;\n    get symbol(): symbol;\n    get null(): null;\n    get undefined(): undefined;\n    get stringOptional(): any;\n    get stringNullable(): any;\n    get numberOptional(): any;\n    get numberNullable(): any;\n    get booleanOptional(): any;\n    get booleanNullable(): any;\n}\n","filePath":"file:///node_modules/@types/zod/__tests__/Mocker.d.ts"},{"content":"import Benchmark from \"benchmark\";\ndeclare const _default: {\n    suites: Benchmark.Suite[];\n};\nexport default _default;\n","filePath":"file:///node_modules/@types/zod/benchmarks/discriminatedUnion.d.ts"},{"content":"export {};\n","filePath":"file:///node_modules/@types/zod/benchmarks/index.d.ts"},{"content":"import Benchmark from \"benchmark\";\ndeclare const _default: {\n    suites: Benchmark.Suite[];\n};\nexport default _default;\n","filePath":"file:///node_modules/@types/zod/benchmarks/object.d.ts"},{"content":"import Benchmark from \"benchmark\";\ndeclare const _default: {\n    suites: Benchmark.Suite[];\n};\nexport default _default;\n","filePath":"file:///node_modules/@types/zod/benchmarks/primitives.d.ts"},{"content":"import Benchmark from \"benchmark\";\ndeclare const _default: {\n    suites: Benchmark.Suite[];\n};\nexport default _default;\n","filePath":"file:///node_modules/@types/zod/benchmarks/realworld.d.ts"},{"content":"import Benchmark from \"benchmark\";\ndeclare const _default: {\n    suites: Benchmark.Suite[];\n};\nexport default _default;\n","filePath":"file:///node_modules/@types/zod/benchmarks/string.d.ts"},{"content":"import Benchmark from \"benchmark\";\ndeclare const _default: {\n    suites: Benchmark.Suite[];\n};\nexport default _default;\n","filePath":"file:///node_modules/@types/zod/benchmarks/union.d.ts"},{"content":"import defaultErrorMap from \"./locales/en\";\nimport type { ZodErrorMap } from \"./ZodError\";\nexport { defaultErrorMap };\nexport declare function setErrorMap(map: ZodErrorMap): void;\nexport declare function getErrorMap(): ZodErrorMap;\n","filePath":"file:///node_modules/@types/zod/errors.d.ts"},{"content":"export * from \"./errors\";\nexport * from \"./helpers/parseUtil\";\nexport * from \"./helpers/typeAliases\";\nexport * from \"./helpers/util\";\nexport * from \"./types\";\nexport * from \"./ZodError\";\n","filePath":"file:///node_modules/@types/zod/external.d.ts"},{"content":"export declare namespace enumUtil {\n    type UnionToIntersectionFn<T> = (T extends unknown ? (k: () => T) => void : never) extends (k: infer Intersection) => void ? Intersection : never;\n    type GetUnionLast<T> = UnionToIntersectionFn<T> extends () => infer Last ? Last : never;\n    type UnionToTuple<T, Tuple extends unknown[] = []> = [T] extends [never] ? Tuple : UnionToTuple<Exclude<T, GetUnionLast<T>>, [GetUnionLast<T>, ...Tuple]>;\n    type CastToStringTuple<T> = T extends [string, ...string[]] ? T : never;\n    export type UnionToTupleString<T> = CastToStringTuple<UnionToTuple<T>>;\n    export {};\n}\n","filePath":"file:///node_modules/@types/zod/helpers/enumUtil.d.ts"},{"content":"export declare namespace errorUtil {\n    type ErrMessage = string | {\n        message?: string;\n    };\n    const errToObj: (message?: ErrMessage | undefined) => {\n        message?: string | undefined;\n    };\n    const toString: (message?: ErrMessage | undefined) => string | undefined;\n}\n","filePath":"file:///node_modules/@types/zod/helpers/errorUtil.d.ts"},{"content":"import type { IssueData, ZodErrorMap, ZodIssue } from \"../ZodError\";\nimport type { ZodParsedType } from \"./util\";\nexport declare const makeIssue: (params: {\n    data: any;\n    path: (string | number)[];\n    errorMaps: ZodErrorMap[];\n    issueData: IssueData;\n}) => ZodIssue;\nexport declare type ParseParams = {\n    path: (string | number)[];\n    errorMap: ZodErrorMap;\n    async: boolean;\n};\nexport declare type ParsePathComponent = string | number;\nexport declare type ParsePath = ParsePathComponent[];\nexport declare const EMPTY_PATH: ParsePath;\nexport interface ParseContext {\n    readonly common: {\n        readonly issues: ZodIssue[];\n        readonly contextualErrorMap?: ZodErrorMap;\n        readonly async: boolean;\n    };\n    readonly path: ParsePath;\n    readonly schemaErrorMap?: ZodErrorMap;\n    readonly parent: ParseContext | null;\n    readonly data: any;\n    readonly parsedType: ZodParsedType;\n}\nexport declare type ParseInput = {\n    data: any;\n    path: (string | number)[];\n    parent: ParseContext;\n};\nexport declare function addIssueToContext(ctx: ParseContext, issueData: IssueData): void;\nexport declare type ObjectPair = {\n    key: SyncParseReturnType<any>;\n    value: SyncParseReturnType<any>;\n};\nexport declare class ParseStatus {\n    value: \"aborted\" | \"dirty\" | \"valid\";\n    dirty(): void;\n    abort(): void;\n    static mergeArray(status: ParseStatus, results: SyncParseReturnType<any>[]): SyncParseReturnType;\n    static mergeObjectAsync(status: ParseStatus, pairs: {\n        key: ParseReturnType<any>;\n        value: ParseReturnType<any>;\n    }[]): Promise<SyncParseReturnType<any>>;\n    static mergeObjectSync(status: ParseStatus, pairs: {\n        key: SyncParseReturnType<any>;\n        value: SyncParseReturnType<any>;\n        alwaysSet?: boolean;\n    }[]): SyncParseReturnType;\n}\nexport interface ParseResult {\n    status: \"aborted\" | \"dirty\" | \"valid\";\n    data: any;\n}\nexport declare type INVALID = {\n    status: \"aborted\";\n};\nexport declare const INVALID: INVALID;\nexport declare type DIRTY<T> = {\n    status: \"dirty\";\n    value: T;\n};\nexport declare const DIRTY: <T>(value: T) => DIRTY<T>;\nexport declare type OK<T> = {\n    status: \"valid\";\n    value: T;\n};\nexport declare const OK: <T>(value: T) => OK<T>;\nexport declare type SyncParseReturnType<T = any> = OK<T> | DIRTY<T> | INVALID;\nexport declare type AsyncParseReturnType<T> = Promise<SyncParseReturnType<T>>;\nexport declare type ParseReturnType<T> = SyncParseReturnType<T> | AsyncParseReturnType<T>;\nexport declare const isAborted: (x: ParseReturnType<any>) => x is INVALID;\nexport declare const isDirty: <T>(x: ParseReturnType<T>) => x is OK<T> | DIRTY<T>;\nexport declare const isValid: <T>(x: ParseReturnType<T>) => x is OK<T> | DIRTY<T>;\nexport declare const isAsync: <T>(x: ParseReturnType<T>) => x is AsyncParseReturnType<T>;\n","filePath":"file:///node_modules/@types/zod/helpers/parseUtil.d.ts"},{"content":"import type { ZodArray, ZodNullable, ZodObject, ZodOptional, ZodRawShape, ZodTuple, ZodTupleItems, ZodTypeAny } from \"../index\";\nexport declare namespace partialUtil {\n    type DeepPartial<T extends ZodTypeAny> = T extends ZodObject<ZodRawShape> ? ZodObject<{\n        [k in keyof T[\"shape\"]]: ZodOptional<DeepPartial<T[\"shape\"][k]>>;\n    }, T[\"_def\"][\"unknownKeys\"], T[\"_def\"][\"catchall\"]> : T extends ZodArray<infer Type, infer Card> ? ZodArray<DeepPartial<Type>, Card> : T extends ZodOptional<infer Type> ? ZodOptional<DeepPartial<Type>> : T extends ZodNullable<infer Type> ? ZodNullable<DeepPartial<Type>> : T extends ZodTuple<infer Items> ? {\n        [k in keyof Items]: Items[k] extends ZodTypeAny ? DeepPartial<Items[k]> : never;\n    } extends infer PI ? PI extends ZodTupleItems ? ZodTuple<PI> : never : never : T;\n}\n","filePath":"file:///node_modules/@types/zod/helpers/partialUtil.d.ts"},{"content":"export declare type Primitive = string | number | symbol | bigint | boolean | null | undefined;\nexport declare type Scalars = Primitive | Primitive[];\n","filePath":"file:///node_modules/@types/zod/helpers/typeAliases.d.ts"},{"content":"export declare namespace util {\n    type AssertEqual<T, U> = (<V>() => V extends T ? 1 : 2) extends <V>() => V extends U ? 1 : 2 ? true : false;\n    export type isAny<T> = 0 extends 1 & T ? true : false;\n    export const assertEqual: <A, B>(val: AssertEqual<A, B>) => AssertEqual<A, B>;\n    export function assertIs<T>(_arg: T): void;\n    export function assertNever(_x: never): never;\n    export type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n    export type OmitKeys<T, K extends string> = Pick<T, Exclude<keyof T, K>>;\n    export type MakePartial<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;\n    export const arrayToEnum: <T extends string, U extends [T, ...T[]]>(items: U) => { [k in U[number]]: k; };\n    export const getValidEnumValues: (obj: any) => any[];\n    export const objectValues: (obj: any) => any[];\n    export const objectKeys: ObjectConstructor[\"keys\"];\n    export const find: <T>(arr: T[], checker: (arg: T) => any) => T | undefined;\n    export type identity<T> = objectUtil.identity<T>;\n    export type flatten<T> = objectUtil.flatten<T>;\n    export type noUndefined<T> = T extends undefined ? never : T;\n    export const isInteger: NumberConstructor[\"isInteger\"];\n    export function joinValues<T extends any[]>(array: T, separator?: string): string;\n    export const jsonStringifyReplacer: (_: string, value: any) => any;\n    export {};\n}\nexport declare namespace objectUtil {\n    export type MergeShapes<U, V> = {\n        [k in Exclude<keyof U, keyof V>]: U[k];\n    } & V;\n    type requiredKeys<T extends object> = {\n        [k in keyof T]: undefined extends T[k] ? never : k;\n    }[keyof T];\n    export type addQuestionMarks<T extends object, R extends keyof T = requiredKeys<T>> = Pick<Required<T>, R> & Partial<T>;\n    export type identity<T> = T;\n    export type flatten<T> = identity<{\n        [k in keyof T]: T[k];\n    }>;\n    export type noNeverKeys<T> = {\n        [k in keyof T]: [T[k]] extends [never] ? never : k;\n    }[keyof T];\n    export type noNever<T> = identity<{\n        [k in noNeverKeys<T>]: k extends keyof T ? T[k] : never;\n    }>;\n    export const mergeShapes: <U, T>(first: U, second: T) => T & U;\n    export type extendShape<A, B> = flatten<Omit<A, keyof B> & B>;\n    export {};\n}\nexport declare const ZodParsedType: {\n    function: \"function\";\n    number: \"number\";\n    string: \"string\";\n    nan: \"nan\";\n    integer: \"integer\";\n    float: \"float\";\n    boolean: \"boolean\";\n    date: \"date\";\n    bigint: \"bigint\";\n    symbol: \"symbol\";\n    undefined: \"undefined\";\n    null: \"null\";\n    array: \"array\";\n    object: \"object\";\n    unknown: \"unknown\";\n    promise: \"promise\";\n    void: \"void\";\n    never: \"never\";\n    map: \"map\";\n    set: \"set\";\n};\nexport declare type ZodParsedType = keyof typeof ZodParsedType;\nexport declare const getParsedType: (data: any) => ZodParsedType;\n","filePath":"file:///node_modules/@types/zod/helpers/util.d.ts"},{"content":"import * as z from \"./external\";\nexport * from \"./external\";\nexport { z };\nexport default z;\n","filePath":"file:///node_modules/@types/zod/index.d.ts"},{"content":"import { ZodErrorMap } from \"../ZodError\";\ndeclare const errorMap: ZodErrorMap;\nexport default errorMap;\n","filePath":"file:///node_modules/@types/zod/locales/en.d.ts"},{"content":"import { enumUtil } from \"./helpers/enumUtil\";\nimport { errorUtil } from \"./helpers/errorUtil\";\nimport { AsyncParseReturnType, ParseContext, ParseInput, ParseParams, ParseReturnType, ParseStatus, SyncParseReturnType } from \"./helpers/parseUtil\";\nimport { partialUtil } from \"./helpers/partialUtil\";\nimport { Primitive } from \"./helpers/typeAliases\";\nimport { objectUtil, util } from \"./helpers/util\";\nimport { IssueData, StringValidation, ZodCustomIssue, ZodError, ZodErrorMap } from \"./ZodError\";\nexport declare type RefinementCtx = {\n    addIssue: (arg: IssueData) => void;\n    path: (string | number)[];\n};\nexport declare type ZodRawShape = {\n    [k: string]: ZodTypeAny;\n};\nexport declare type ZodTypeAny = ZodType<any, any, any>;\nexport declare type TypeOf<T extends ZodType<any, any, any>> = T[\"_output\"];\nexport declare type input<T extends ZodType<any, any, any>> = T[\"_input\"];\nexport declare type output<T extends ZodType<any, any, any>> = T[\"_output\"];\nexport type { TypeOf as infer };\nexport declare type CustomErrorParams = Partial<util.Omit<ZodCustomIssue, \"code\">>;\nexport interface ZodTypeDef {\n    errorMap?: ZodErrorMap;\n    description?: string;\n}\nexport declare type RawCreateParams = {\n    errorMap?: ZodErrorMap;\n    invalid_type_error?: string;\n    required_error?: string;\n    description?: string;\n} | undefined;\nexport declare type ProcessedCreateParams = {\n    errorMap?: ZodErrorMap;\n    description?: string;\n};\nexport declare type SafeParseSuccess<Output> = {\n    success: true;\n    data: Output;\n};\nexport declare type SafeParseError<Input> = {\n    success: false;\n    error: ZodError<Input>;\n};\nexport declare type SafeParseReturnType<Input, Output> = SafeParseSuccess<Output> | SafeParseError<Input>;\nexport declare abstract class ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {\n    readonly _type: Output;\n    readonly _output: Output;\n    readonly _input: Input;\n    readonly _def: Def;\n    get description(): string | undefined;\n    abstract _parse(input: ParseInput): ParseReturnType<Output>;\n    _getType(input: ParseInput): string;\n    _getOrReturnCtx(input: ParseInput, ctx?: ParseContext | undefined): ParseContext;\n    _processInputParams(input: ParseInput): {\n        status: ParseStatus;\n        ctx: ParseContext;\n    };\n    _parseSync(input: ParseInput): SyncParseReturnType<Output>;\n    _parseAsync(input: ParseInput): AsyncParseReturnType<Output>;\n    parse(data: unknown, params?: Partial<ParseParams>): Output;\n    safeParse(data: unknown, params?: Partial<ParseParams>): SafeParseReturnType<Input, Output>;\n    parseAsync(data: unknown, params?: Partial<ParseParams>): Promise<Output>;\n    safeParseAsync(data: unknown, params?: Partial<ParseParams>): Promise<SafeParseReturnType<Input, Output>>;\n    spa: (data: unknown, params?: Partial<ParseParams> | undefined) => Promise<SafeParseReturnType<Input, Output>>;\n    refine<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, RefinedOutput, Input>;\n    refine(check: (arg: Output) => unknown | Promise<unknown>, message?: string | CustomErrorParams | ((arg: Output) => CustomErrorParams)): ZodEffects<this, Output, Input>;\n    refinement<RefinedOutput extends Output>(check: (arg: Output) => arg is RefinedOutput, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, RefinedOutput, Input>;\n    refinement(check: (arg: Output) => boolean, refinementData: IssueData | ((arg: Output, ctx: RefinementCtx) => IssueData)): ZodEffects<this, Output, Input>;\n    _refinement(refinement: RefinementEffect<Output>[\"refinement\"]): ZodEffects<this, Output, Input>;\n    superRefine<RefinedOutput extends Output>(refinement: (arg: Output, ctx: RefinementCtx) => arg is RefinedOutput): ZodEffects<this, RefinedOutput, Input>;\n    superRefine(refinement: (arg: Output, ctx: RefinementCtx) => void): ZodEffects<this, Output, Input>;\n    constructor(def: Def);\n    optional(): ZodOptional<this>;\n    nullable(): ZodNullable<this>;\n    nullish(): ZodOptional<ZodNullable<this>>;\n    array(): ZodArray<this>;\n    promise(): ZodPromise<this>;\n    or<T extends ZodTypeAny>(option: T): ZodUnion<[this, T]>;\n    and<T extends ZodTypeAny>(incoming: T): ZodIntersection<this, T>;\n    transform<NewOut>(transform: (arg: Output, ctx: RefinementCtx) => NewOut | Promise<NewOut>): ZodEffects<this, NewOut>;\n    default(def: util.noUndefined<Input>): ZodDefault<this>;\n    default(def: () => util.noUndefined<Input>): ZodDefault<this>;\n    brand<B extends string | number | symbol>(brand?: B): ZodBranded<this, B>;\n    catch(def: Output): ZodCatch<this>;\n    catch(def: (ctx: {\n        error: ZodError;\n        input: Input;\n    }) => Output): ZodCatch<this>;\n    describe(description: string): this;\n    pipe<T extends ZodTypeAny>(target: T): ZodPipeline<this, T>;\n    isOptional(): boolean;\n    isNullable(): boolean;\n}\nexport declare type IpVersion = \"v4\" | \"v6\";\nexport declare type ZodStringCheck = {\n    kind: \"min\";\n    value: number;\n    message?: string;\n} | {\n    kind: \"max\";\n    value: number;\n    message?: string;\n} | {\n    kind: \"length\";\n    value: number;\n    message?: string;\n} | {\n    kind: \"email\";\n    message?: string;\n} | {\n    kind: \"url\";\n    message?: string;\n} | {\n    kind: \"emoji\";\n    message?: string;\n} | {\n    kind: \"uuid\";\n    message?: string;\n} | {\n    kind: \"cuid\";\n    message?: string;\n} | {\n    kind: \"includes\";\n    value: string;\n    position?: number;\n    message?: string;\n} | {\n    kind: \"cuid2\";\n    message?: string;\n} | {\n    kind: \"ulid\";\n    message?: string;\n} | {\n    kind: \"startsWith\";\n    value: string;\n    message?: string;\n} | {\n    kind: \"endsWith\";\n    value: string;\n    message?: string;\n} | {\n    kind: \"regex\";\n    regex: RegExp;\n    message?: string;\n} | {\n    kind: \"trim\";\n    message?: string;\n} | {\n    kind: \"toLowerCase\";\n    message?: string;\n} | {\n    kind: \"toUpperCase\";\n    message?: string;\n} | {\n    kind: \"datetime\";\n    offset: boolean;\n    precision: number | null;\n    message?: string;\n} | {\n    kind: \"ip\";\n    version?: IpVersion;\n    message?: string;\n};\nexport interface ZodStringDef extends ZodTypeDef {\n    checks: ZodStringCheck[];\n    typeName: ZodFirstPartyTypeKind.ZodString;\n    coerce: boolean;\n}\nexport declare class ZodString extends ZodType<string, ZodStringDef> {\n    _parse(input: ParseInput): ParseReturnType<string>;\n    protected _regex: (regex: RegExp, validation: StringValidation, message?: errorUtil.ErrMessage | undefined) => ZodEffects<this, string, string>;\n    _addCheck(check: ZodStringCheck): ZodString;\n    email(message?: errorUtil.ErrMessage): ZodString;\n    url(message?: errorUtil.ErrMessage): ZodString;\n    emoji(message?: errorUtil.ErrMessage): ZodString;\n    uuid(message?: errorUtil.ErrMessage): ZodString;\n    cuid(message?: errorUtil.ErrMessage): ZodString;\n    cuid2(message?: errorUtil.ErrMessage): ZodString;\n    ulid(message?: errorUtil.ErrMessage): ZodString;\n    ip(options?: string | {\n        version?: \"v4\" | \"v6\";\n        message?: string;\n    }): ZodString;\n    datetime(options?: string | {\n        message?: string | undefined;\n        precision?: number | null;\n        offset?: boolean;\n    }): ZodString;\n    regex(regex: RegExp, message?: errorUtil.ErrMessage): ZodString;\n    includes(value: string, options?: {\n        message?: string;\n        position?: number;\n    }): ZodString;\n    startsWith(value: string, message?: errorUtil.ErrMessage): ZodString;\n    endsWith(value: string, message?: errorUtil.ErrMessage): ZodString;\n    min(minLength: number, message?: errorUtil.ErrMessage): ZodString;\n    max(maxLength: number, message?: errorUtil.ErrMessage): ZodString;\n    length(len: number, message?: errorUtil.ErrMessage): ZodString;\n    nonempty: (message?: errorUtil.ErrMessage | undefined) => ZodString;\n    trim: () => ZodString;\n    toLowerCase: () => ZodString;\n    toUpperCase: () => ZodString;\n    get isDatetime(): boolean;\n    get isEmail(): boolean;\n    get isURL(): boolean;\n    get isEmoji(): boolean;\n    get isUUID(): boolean;\n    get isCUID(): boolean;\n    get isCUID2(): boolean;\n    get isULID(): boolean;\n    get isIP(): boolean;\n    get minLength(): number | null;\n    get maxLength(): number | null;\n    static create: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: true | undefined;\n    }) | undefined) => ZodString;\n}\nexport declare type ZodNumberCheck = {\n    kind: \"min\";\n    value: number;\n    inclusive: boolean;\n    message?: string;\n} | {\n    kind: \"max\";\n    value: number;\n    inclusive: boolean;\n    message?: string;\n} | {\n    kind: \"int\";\n    message?: string;\n} | {\n    kind: \"multipleOf\";\n    value: number;\n    message?: string;\n} | {\n    kind: \"finite\";\n    message?: string;\n};\nexport interface ZodNumberDef extends ZodTypeDef {\n    checks: ZodNumberCheck[];\n    typeName: ZodFirstPartyTypeKind.ZodNumber;\n    coerce: boolean;\n}\nexport declare class ZodNumber extends ZodType<number, ZodNumberDef> {\n    _parse(input: ParseInput): ParseReturnType<number>;\n    static create: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodNumber;\n    gte(value: number, message?: errorUtil.ErrMessage): ZodNumber;\n    min: (value: number, message?: errorUtil.ErrMessage | undefined) => ZodNumber;\n    gt(value: number, message?: errorUtil.ErrMessage): ZodNumber;\n    lte(value: number, message?: errorUtil.ErrMessage): ZodNumber;\n    max: (value: number, message?: errorUtil.ErrMessage | undefined) => ZodNumber;\n    lt(value: number, message?: errorUtil.ErrMessage): ZodNumber;\n    protected setLimit(kind: \"min\" | \"max\", value: number, inclusive: boolean, message?: string): ZodNumber;\n    _addCheck(check: ZodNumberCheck): ZodNumber;\n    int(message?: errorUtil.ErrMessage): ZodNumber;\n    positive(message?: errorUtil.ErrMessage): ZodNumber;\n    negative(message?: errorUtil.ErrMessage): ZodNumber;\n    nonpositive(message?: errorUtil.ErrMessage): ZodNumber;\n    nonnegative(message?: errorUtil.ErrMessage): ZodNumber;\n    multipleOf(value: number, message?: errorUtil.ErrMessage): ZodNumber;\n    step: (value: number, message?: errorUtil.ErrMessage | undefined) => ZodNumber;\n    finite(message?: errorUtil.ErrMessage): ZodNumber;\n    safe(message?: errorUtil.ErrMessage): ZodNumber;\n    get minValue(): number | null;\n    get maxValue(): number | null;\n    get isInt(): boolean;\n    get isFinite(): boolean;\n}\nexport declare type ZodBigIntCheck = {\n    kind: \"min\";\n    value: bigint;\n    inclusive: boolean;\n    message?: string;\n} | {\n    kind: \"max\";\n    value: bigint;\n    inclusive: boolean;\n    message?: string;\n} | {\n    kind: \"multipleOf\";\n    value: bigint;\n    message?: string;\n};\nexport interface ZodBigIntDef extends ZodTypeDef {\n    checks: ZodBigIntCheck[];\n    typeName: ZodFirstPartyTypeKind.ZodBigInt;\n    coerce: boolean;\n}\nexport declare class ZodBigInt extends ZodType<bigint, ZodBigIntDef> {\n    _parse(input: ParseInput): ParseReturnType<bigint>;\n    static create: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodBigInt;\n    gte(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;\n    min: (value: bigint, message?: errorUtil.ErrMessage | undefined) => ZodBigInt;\n    gt(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;\n    lte(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;\n    max: (value: bigint, message?: errorUtil.ErrMessage | undefined) => ZodBigInt;\n    lt(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;\n    protected setLimit(kind: \"min\" | \"max\", value: bigint, inclusive: boolean, message?: string): ZodBigInt;\n    _addCheck(check: ZodBigIntCheck): ZodBigInt;\n    positive(message?: errorUtil.ErrMessage): ZodBigInt;\n    negative(message?: errorUtil.ErrMessage): ZodBigInt;\n    nonpositive(message?: errorUtil.ErrMessage): ZodBigInt;\n    nonnegative(message?: errorUtil.ErrMessage): ZodBigInt;\n    multipleOf(value: bigint, message?: errorUtil.ErrMessage): ZodBigInt;\n    get minValue(): bigint | null;\n    get maxValue(): bigint | null;\n}\nexport interface ZodBooleanDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodBoolean;\n    coerce: boolean;\n}\nexport declare class ZodBoolean extends ZodType<boolean, ZodBooleanDef> {\n    _parse(input: ParseInput): ParseReturnType<boolean>;\n    static create: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodBoolean;\n}\nexport declare type ZodDateCheck = {\n    kind: \"min\";\n    value: number;\n    message?: string;\n} | {\n    kind: \"max\";\n    value: number;\n    message?: string;\n};\nexport interface ZodDateDef extends ZodTypeDef {\n    checks: ZodDateCheck[];\n    coerce: boolean;\n    typeName: ZodFirstPartyTypeKind.ZodDate;\n}\nexport declare class ZodDate extends ZodType<Date, ZodDateDef> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    _addCheck(check: ZodDateCheck): ZodDate;\n    min(minDate: Date, message?: errorUtil.ErrMessage): ZodDate;\n    max(maxDate: Date, message?: errorUtil.ErrMessage): ZodDate;\n    get minDate(): Date | null;\n    get maxDate(): Date | null;\n    static create: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodDate;\n}\nexport interface ZodSymbolDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodSymbol;\n}\nexport declare class ZodSymbol extends ZodType<symbol, ZodSymbolDef, symbol> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: (params?: RawCreateParams) => ZodSymbol;\n}\nexport interface ZodUndefinedDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodUndefined;\n}\nexport declare class ZodUndefined extends ZodType<undefined, ZodUndefinedDef> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    params?: RawCreateParams;\n    static create: (params?: RawCreateParams) => ZodUndefined;\n}\nexport interface ZodNullDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodNull;\n}\nexport declare class ZodNull extends ZodType<null, ZodNullDef> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: (params?: RawCreateParams) => ZodNull;\n}\nexport interface ZodAnyDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodAny;\n}\nexport declare class ZodAny extends ZodType<any, ZodAnyDef> {\n    _any: true;\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: (params?: RawCreateParams) => ZodAny;\n}\nexport interface ZodUnknownDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodUnknown;\n}\nexport declare class ZodUnknown extends ZodType<unknown, ZodUnknownDef> {\n    _unknown: true;\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: (params?: RawCreateParams) => ZodUnknown;\n}\nexport interface ZodNeverDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodNever;\n}\nexport declare class ZodNever extends ZodType<never, ZodNeverDef> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: (params?: RawCreateParams) => ZodNever;\n}\nexport interface ZodVoidDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodVoid;\n}\nexport declare class ZodVoid extends ZodType<void, ZodVoidDef> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: (params?: RawCreateParams) => ZodVoid;\n}\nexport interface ZodArrayDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    type: T;\n    typeName: ZodFirstPartyTypeKind.ZodArray;\n    exactLength: {\n        value: number;\n        message?: string;\n    } | null;\n    minLength: {\n        value: number;\n        message?: string;\n    } | null;\n    maxLength: {\n        value: number;\n        message?: string;\n    } | null;\n}\nexport declare type ArrayCardinality = \"many\" | \"atleastone\";\nexport declare type arrayOutputType<T extends ZodTypeAny, Cardinality extends ArrayCardinality = \"many\"> = Cardinality extends \"atleastone\" ? [T[\"_output\"], ...T[\"_output\"][]] : T[\"_output\"][];\nexport declare class ZodArray<T extends ZodTypeAny, Cardinality extends ArrayCardinality = \"many\"> extends ZodType<arrayOutputType<T, Cardinality>, ZodArrayDef<T>, Cardinality extends \"atleastone\" ? [T[\"_input\"], ...T[\"_input\"][]] : T[\"_input\"][]> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get element(): T;\n    min(minLength: number, message?: errorUtil.ErrMessage): this;\n    max(maxLength: number, message?: errorUtil.ErrMessage): this;\n    length(len: number, message?: errorUtil.ErrMessage): this;\n    nonempty(message?: errorUtil.ErrMessage): ZodArray<T, \"atleastone\">;\n    static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodArray<T_1, \"many\">;\n}\nexport declare type ZodNonEmptyArray<T extends ZodTypeAny> = ZodArray<T, \"atleastone\">;\nexport declare type UnknownKeysParam = \"passthrough\" | \"strict\" | \"strip\";\nexport interface ZodObjectDef<T extends ZodRawShape = ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodObject;\n    shape: () => T;\n    catchall: Catchall;\n    unknownKeys: UnknownKeys;\n}\nexport declare type mergeTypes<A, B> = {\n    [k in keyof A | keyof B]: k extends keyof B ? B[k] : k extends keyof A ? A[k] : never;\n};\nexport declare type objectOutputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectUtil.flatten<objectUtil.addQuestionMarks<baseObjectOutputType<Shape>>> & CatchallOutput<Catchall> & PassthroughType<UnknownKeys>;\nexport declare type baseObjectOutputType<Shape extends ZodRawShape> = {\n    [k in keyof Shape]: Shape[k][\"_output\"];\n};\nexport declare type objectInputType<Shape extends ZodRawShape, Catchall extends ZodTypeAny, UnknownKeys extends UnknownKeysParam = UnknownKeysParam> = objectUtil.flatten<baseObjectInputType<Shape>> & CatchallInput<Catchall> & PassthroughType<UnknownKeys>;\nexport declare type baseObjectInputType<Shape extends ZodRawShape> = objectUtil.addQuestionMarks<{\n    [k in keyof Shape]: Shape[k][\"_input\"];\n}>;\nexport declare type CatchallOutput<T extends ZodTypeAny> = ZodTypeAny extends T ? unknown : {\n    [k: string]: T[\"_output\"];\n};\nexport declare type CatchallInput<T extends ZodTypeAny> = ZodTypeAny extends T ? unknown : {\n    [k: string]: T[\"_input\"];\n};\nexport declare type PassthroughType<T extends UnknownKeysParam> = T extends \"passthrough\" ? {\n    [k: string]: unknown;\n} : unknown;\nexport declare type deoptional<T extends ZodTypeAny> = T extends ZodOptional<infer U> ? deoptional<U> : T extends ZodNullable<infer U> ? ZodNullable<deoptional<U>> : T;\nexport declare type SomeZodObject = ZodObject<ZodRawShape, UnknownKeysParam, ZodTypeAny>;\nexport declare type noUnrecognized<Obj extends object, Shape extends object> = {\n    [k in keyof Obj]: k extends keyof Shape ? Obj[k] : never;\n};\nexport declare class ZodObject<T extends ZodRawShape, UnknownKeys extends UnknownKeysParam = UnknownKeysParam, Catchall extends ZodTypeAny = ZodTypeAny, Output = objectOutputType<T, Catchall, UnknownKeys>, Input = objectInputType<T, Catchall, UnknownKeys>> extends ZodType<Output, ZodObjectDef<T, UnknownKeys, Catchall>, Input> {\n    private _cached;\n    _getCached(): {\n        shape: T;\n        keys: string[];\n    };\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get shape(): T;\n    strict(message?: errorUtil.ErrMessage): ZodObject<T, \"strict\", Catchall>;\n    strip(): ZodObject<T, \"strip\", Catchall>;\n    passthrough(): ZodObject<T, \"passthrough\", Catchall>;\n    nonstrict: () => ZodObject<T, \"passthrough\", Catchall>;\n    extend<Augmentation extends ZodRawShape>(augmentation: Augmentation): ZodObject<objectUtil.extendShape<T, Augmentation>, UnknownKeys, Catchall>;\n    augment: <Augmentation extends ZodRawShape>(augmentation: Augmentation) => ZodObject<{ [k in keyof (Omit<T, keyof Augmentation> & Augmentation)]: (Omit<T, keyof Augmentation> & Augmentation)[k]; }, UnknownKeys, Catchall, objectOutputType<{ [k in keyof (Omit<T, keyof Augmentation> & Augmentation)]: (Omit<T, keyof Augmentation> & Augmentation)[k]; }, Catchall, UnknownKeys>, objectInputType<{ [k in keyof (Omit<T, keyof Augmentation> & Augmentation)]: (Omit<T, keyof Augmentation> & Augmentation)[k]; }, Catchall, UnknownKeys>>;\n    merge<Incoming extends AnyZodObject, Augmentation extends Incoming[\"shape\"]>(merging: Incoming): ZodObject<objectUtil.extendShape<T, Augmentation>, Incoming[\"_def\"][\"unknownKeys\"], Incoming[\"_def\"][\"catchall\"]>;\n    setKey<Key extends string, Schema extends ZodTypeAny>(key: Key, schema: Schema): ZodObject<T & {\n        [k in Key]: Schema;\n    }, UnknownKeys, Catchall>;\n    catchall<Index extends ZodTypeAny>(index: Index): ZodObject<T, UnknownKeys, Index>;\n    pick<Mask extends {\n        [k in keyof T]?: true;\n    }>(mask: Mask): ZodObject<Pick<T, Extract<keyof T, keyof Mask>>, UnknownKeys, Catchall>;\n    omit<Mask extends {\n        [k in keyof T]?: true;\n    }>(mask: Mask): ZodObject<Omit<T, keyof Mask>, UnknownKeys, Catchall>;\n    deepPartial(): partialUtil.DeepPartial<this>;\n    partial(): ZodObject<{\n        [k in keyof T]: ZodOptional<T[k]>;\n    }, UnknownKeys, Catchall>;\n    partial<Mask extends {\n        [k in keyof T]?: true;\n    }>(mask: Mask): ZodObject<objectUtil.noNever<{\n        [k in keyof T]: k extends keyof Mask ? ZodOptional<T[k]> : T[k];\n    }>, UnknownKeys, Catchall>;\n    required(): ZodObject<{\n        [k in keyof T]: deoptional<T[k]>;\n    }, UnknownKeys, Catchall>;\n    required<Mask extends {\n        [k in keyof T]?: true;\n    }>(mask: Mask): ZodObject<objectUtil.noNever<{\n        [k in keyof T]: k extends keyof Mask ? deoptional<T[k]> : T[k];\n    }>, UnknownKeys, Catchall>;\n    keyof(): ZodEnum<enumUtil.UnionToTupleString<keyof T>>;\n    static create: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, \"strip\", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, { [k in keyof baseObjectOutputType<T_1>]: undefined extends baseObjectOutputType<T_1>[k] ? never : k; }[keyof T_1]>]: objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, { [k in keyof baseObjectOutputType<T_1>]: undefined extends baseObjectOutputType<T_1>[k] ? never : k; }[keyof T_1]>[k_1]; }, { [k_2 in keyof baseObjectInputType<T_1>]: baseObjectInputType<T_1>[k_2]; }>;\n    static strictCreate: <T_1 extends ZodRawShape>(shape: T_1, params?: RawCreateParams) => ZodObject<T_1, \"strict\", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, { [k in keyof baseObjectOutputType<T_1>]: undefined extends baseObjectOutputType<T_1>[k] ? never : k; }[keyof T_1]>]: objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, { [k in keyof baseObjectOutputType<T_1>]: undefined extends baseObjectOutputType<T_1>[k] ? never : k; }[keyof T_1]>[k_1]; }, { [k_2 in keyof baseObjectInputType<T_1>]: baseObjectInputType<T_1>[k_2]; }>;\n    static lazycreate: <T_1 extends ZodRawShape>(shape: () => T_1, params?: RawCreateParams) => ZodObject<T_1, \"strip\", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, { [k in keyof baseObjectOutputType<T_1>]: undefined extends baseObjectOutputType<T_1>[k] ? never : k; }[keyof T_1]>]: objectUtil.addQuestionMarks<baseObjectOutputType<T_1>, { [k in keyof baseObjectOutputType<T_1>]: undefined extends baseObjectOutputType<T_1>[k] ? never : k; }[keyof T_1]>[k_1]; }, { [k_2 in keyof baseObjectInputType<T_1>]: baseObjectInputType<T_1>[k_2]; }>;\n}\nexport declare type AnyZodObject = ZodObject<any, any, any>;\nexport declare type ZodUnionOptions = Readonly<[ZodTypeAny, ...ZodTypeAny[]]>;\nexport interface ZodUnionDef<T extends ZodUnionOptions = Readonly<[\n    ZodTypeAny,\n    ZodTypeAny,\n    ...ZodTypeAny[]\n]>> extends ZodTypeDef {\n    options: T;\n    typeName: ZodFirstPartyTypeKind.ZodUnion;\n}\nexport declare class ZodUnion<T extends ZodUnionOptions> extends ZodType<T[number][\"_output\"], ZodUnionDef<T>, T[number][\"_input\"]> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get options(): T;\n    static create: <T_1 extends readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(types: T_1, params?: RawCreateParams) => ZodUnion<T_1>;\n}\nexport declare type ZodDiscriminatedUnionOption<Discriminator extends string> = ZodObject<{\n    [key in Discriminator]: ZodTypeAny;\n} & ZodRawShape, UnknownKeysParam, ZodTypeAny>;\nexport interface ZodDiscriminatedUnionDef<Discriminator extends string, Options extends ZodDiscriminatedUnionOption<string>[] = ZodDiscriminatedUnionOption<string>[]> extends ZodTypeDef {\n    discriminator: Discriminator;\n    options: Options;\n    optionsMap: Map<Primitive, ZodDiscriminatedUnionOption<any>>;\n    typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion;\n}\nexport declare class ZodDiscriminatedUnion<Discriminator extends string, Options extends ZodDiscriminatedUnionOption<Discriminator>[]> extends ZodType<output<Options[number]>, ZodDiscriminatedUnionDef<Discriminator, Options>, input<Options[number]>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get discriminator(): Discriminator;\n    get options(): Options;\n    get optionsMap(): Map<Primitive, ZodDiscriminatedUnionOption<any>>;\n    static create<Discriminator extends string, Types extends [\n        ZodDiscriminatedUnionOption<Discriminator>,\n        ...ZodDiscriminatedUnionOption<Discriminator>[]\n    ]>(discriminator: Discriminator, options: Types, params?: RawCreateParams): ZodDiscriminatedUnion<Discriminator, Types>;\n}\nexport interface ZodIntersectionDef<T extends ZodTypeAny = ZodTypeAny, U extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    left: T;\n    right: U;\n    typeName: ZodFirstPartyTypeKind.ZodIntersection;\n}\nexport declare class ZodIntersection<T extends ZodTypeAny, U extends ZodTypeAny> extends ZodType<T[\"_output\"] & U[\"_output\"], ZodIntersectionDef<T, U>, T[\"_input\"] & U[\"_input\"]> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: <T_1 extends ZodTypeAny, U_1 extends ZodTypeAny>(left: T_1, right: U_1, params?: RawCreateParams) => ZodIntersection<T_1, U_1>;\n}\nexport declare type ZodTupleItems = [ZodTypeAny, ...ZodTypeAny[]];\nexport declare type AssertArray<T> = T extends any[] ? T : never;\nexport declare type OutputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{\n    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][\"_output\"] : never;\n}>;\nexport declare type OutputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...OutputTypeOfTuple<T>, ...Rest[\"_output\"][]] : OutputTypeOfTuple<T>;\nexport declare type InputTypeOfTuple<T extends ZodTupleItems | []> = AssertArray<{\n    [k in keyof T]: T[k] extends ZodType<any, any> ? T[k][\"_input\"] : never;\n}>;\nexport declare type InputTypeOfTupleWithRest<T extends ZodTupleItems | [], Rest extends ZodTypeAny | null = null> = Rest extends ZodTypeAny ? [...InputTypeOfTuple<T>, ...Rest[\"_input\"][]] : InputTypeOfTuple<T>;\nexport interface ZodTupleDef<T extends ZodTupleItems | [] = ZodTupleItems, Rest extends ZodTypeAny | null = null> extends ZodTypeDef {\n    items: T;\n    rest: Rest;\n    typeName: ZodFirstPartyTypeKind.ZodTuple;\n}\nexport declare type AnyZodTuple = ZodTuple<[\n    ZodTypeAny,\n    ...ZodTypeAny[]\n] | [], ZodTypeAny | null>;\nexport declare class ZodTuple<T extends [ZodTypeAny, ...ZodTypeAny[]] | [] = [ZodTypeAny, ...ZodTypeAny[]], Rest extends ZodTypeAny | null = null> extends ZodType<OutputTypeOfTupleWithRest<T, Rest>, ZodTupleDef<T, Rest>, InputTypeOfTupleWithRest<T, Rest>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get items(): T;\n    rest<Rest extends ZodTypeAny>(rest: Rest): ZodTuple<T, Rest>;\n    static create: <T_1 extends [] | [ZodTypeAny, ...ZodTypeAny[]]>(schemas: T_1, params?: RawCreateParams) => ZodTuple<T_1, null>;\n}\nexport interface ZodRecordDef<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    valueType: Value;\n    keyType: Key;\n    typeName: ZodFirstPartyTypeKind.ZodRecord;\n}\nexport declare type KeySchema = ZodType<string | number | symbol, any, any>;\nexport declare type RecordType<K extends string | number | symbol, V> = [\n    string\n] extends [K] ? Record<K, V> : [number] extends [K] ? Record<K, V> : [symbol] extends [K] ? Record<K, V> : [BRAND<string | number | symbol>] extends [K] ? Record<K, V> : Partial<Record<K, V>>;\nexport declare class ZodRecord<Key extends KeySchema = ZodString, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<RecordType<Key[\"_output\"], Value[\"_output\"]>, ZodRecordDef<Key, Value>, RecordType<Key[\"_input\"], Value[\"_input\"]>> {\n    get keySchema(): Key;\n    get valueSchema(): Value;\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get element(): Value;\n    static create<Value extends ZodTypeAny>(valueType: Value, params?: RawCreateParams): ZodRecord<ZodString, Value>;\n    static create<Keys extends KeySchema, Value extends ZodTypeAny>(keySchema: Keys, valueType: Value, params?: RawCreateParams): ZodRecord<Keys, Value>;\n}\nexport interface ZodMapDef<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    valueType: Value;\n    keyType: Key;\n    typeName: ZodFirstPartyTypeKind.ZodMap;\n}\nexport declare class ZodMap<Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny> extends ZodType<Map<Key[\"_output\"], Value[\"_output\"]>, ZodMapDef<Key, Value>, Map<Key[\"_input\"], Value[\"_input\"]>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: <Key_1 extends ZodTypeAny = ZodTypeAny, Value_1 extends ZodTypeAny = ZodTypeAny>(keyType: Key_1, valueType: Value_1, params?: RawCreateParams) => ZodMap<Key_1, Value_1>;\n}\nexport interface ZodSetDef<Value extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    valueType: Value;\n    typeName: ZodFirstPartyTypeKind.ZodSet;\n    minSize: {\n        value: number;\n        message?: string;\n    } | null;\n    maxSize: {\n        value: number;\n        message?: string;\n    } | null;\n}\nexport declare class ZodSet<Value extends ZodTypeAny = ZodTypeAny> extends ZodType<Set<Value[\"_output\"]>, ZodSetDef<Value>, Set<Value[\"_input\"]>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    min(minSize: number, message?: errorUtil.ErrMessage): this;\n    max(maxSize: number, message?: errorUtil.ErrMessage): this;\n    size(size: number, message?: errorUtil.ErrMessage): this;\n    nonempty(message?: errorUtil.ErrMessage): ZodSet<Value>;\n    static create: <Value_1 extends ZodTypeAny = ZodTypeAny>(valueType: Value_1, params?: RawCreateParams) => ZodSet<Value_1>;\n}\nexport interface ZodFunctionDef<Args extends ZodTuple<any, any> = ZodTuple<any, any>, Returns extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    args: Args;\n    returns: Returns;\n    typeName: ZodFirstPartyTypeKind.ZodFunction;\n}\nexport declare type OuterTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = Args[\"_input\"] extends Array<any> ? (...args: Args[\"_input\"]) => Returns[\"_output\"] : never;\nexport declare type InnerTypeOfFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> = Args[\"_output\"] extends Array<any> ? (...args: Args[\"_output\"]) => Returns[\"_input\"] : never;\nexport declare class ZodFunction<Args extends ZodTuple<any, any>, Returns extends ZodTypeAny> extends ZodType<OuterTypeOfFunction<Args, Returns>, ZodFunctionDef<Args, Returns>, InnerTypeOfFunction<Args, Returns>> {\n    _parse(input: ParseInput): ParseReturnType<any>;\n    parameters(): Args;\n    returnType(): Returns;\n    args<Items extends Parameters<(typeof ZodTuple)[\"create\"]>[0]>(...items: Items): ZodFunction<ZodTuple<Items, ZodUnknown>, Returns>;\n    returns<NewReturnType extends ZodType<any, any>>(returnType: NewReturnType): ZodFunction<Args, NewReturnType>;\n    implement<F extends InnerTypeOfFunction<Args, Returns>>(func: F): ReturnType<F> extends Returns[\"_output\"] ? (...args: Args[\"_input\"]) => ReturnType<F> : OuterTypeOfFunction<Args, Returns>;\n    strictImplement(func: InnerTypeOfFunction<Args, Returns>): InnerTypeOfFunction<Args, Returns>;\n    validate: <F extends InnerTypeOfFunction<Args, Returns>>(func: F) => ReturnType<F> extends Returns[\"_output\"] ? (...args: Args[\"_input\"]) => ReturnType<F> : OuterTypeOfFunction<Args, Returns>;\n    static create(): ZodFunction<ZodTuple<[], ZodUnknown>, ZodUnknown>;\n    static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>>(args: T): ZodFunction<T, ZodUnknown>;\n    static create<T extends AnyZodTuple, U extends ZodTypeAny>(args: T, returns: U): ZodFunction<T, U>;\n    static create<T extends AnyZodTuple = ZodTuple<[], ZodUnknown>, U extends ZodTypeAny = ZodUnknown>(args: T, returns: U, params?: RawCreateParams): ZodFunction<T, U>;\n}\nexport interface ZodLazyDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    getter: () => T;\n    typeName: ZodFirstPartyTypeKind.ZodLazy;\n}\nexport declare class ZodLazy<T extends ZodTypeAny> extends ZodType<output<T>, ZodLazyDef<T>, input<T>> {\n    get schema(): T;\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: <T_1 extends ZodTypeAny>(getter: () => T_1, params?: RawCreateParams) => ZodLazy<T_1>;\n}\nexport interface ZodLiteralDef<T = any> extends ZodTypeDef {\n    value: T;\n    typeName: ZodFirstPartyTypeKind.ZodLiteral;\n}\nexport declare class ZodLiteral<T> extends ZodType<T, ZodLiteralDef<T>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get value(): T;\n    static create: <T_1 extends Primitive>(value: T_1, params?: RawCreateParams) => ZodLiteral<T_1>;\n}\nexport declare type ArrayKeys = keyof any[];\nexport declare type Indices<T> = Exclude<keyof T, ArrayKeys>;\nexport declare type EnumValues = [string, ...string[]];\nexport declare type Values<T extends EnumValues> = {\n    [k in T[number]]: k;\n};\nexport interface ZodEnumDef<T extends EnumValues = EnumValues> extends ZodTypeDef {\n    values: T;\n    typeName: ZodFirstPartyTypeKind.ZodEnum;\n}\nexport declare type Writeable<T> = {\n    -readonly [P in keyof T]: T[P];\n};\nexport declare type FilterEnum<Values, ToExclude> = Values extends [] ? [] : Values extends [infer Head, ...infer Rest] ? Head extends ToExclude ? FilterEnum<Rest, ToExclude> : [Head, ...FilterEnum<Rest, ToExclude>] : never;\nexport declare type typecast<A, T> = A extends T ? A : never;\ndeclare function createZodEnum<U extends string, T extends Readonly<[U, ...U[]]>>(values: T, params?: RawCreateParams): ZodEnum<Writeable<T>>;\ndeclare function createZodEnum<U extends string, T extends [U, ...U[]]>(values: T, params?: RawCreateParams): ZodEnum<T>;\nexport declare class ZodEnum<T extends [string, ...string[]]> extends ZodType<T[number], ZodEnumDef<T>> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    get options(): T;\n    get enum(): Values<T>;\n    get Values(): Values<T>;\n    get Enum(): Values<T>;\n    extract<ToExtract extends readonly [T[number], ...T[number][]]>(values: ToExtract): ZodEnum<Writeable<ToExtract>>;\n    exclude<ToExclude extends readonly [T[number], ...T[number][]]>(values: ToExclude): ZodEnum<typecast<Writeable<FilterEnum<T, ToExclude[number]>>, [string, ...string[]]>>;\n    static create: typeof createZodEnum;\n}\nexport interface ZodNativeEnumDef<T extends EnumLike = EnumLike> extends ZodTypeDef {\n    values: T;\n    typeName: ZodFirstPartyTypeKind.ZodNativeEnum;\n}\nexport declare type EnumLike = {\n    [k: string]: string | number;\n    [nu: number]: string;\n};\nexport declare class ZodNativeEnum<T extends EnumLike> extends ZodType<T[keyof T], ZodNativeEnumDef<T>> {\n    _parse(input: ParseInput): ParseReturnType<T[keyof T]>;\n    get enum(): T;\n    static create: <T_1 extends EnumLike>(values: T_1, params?: RawCreateParams) => ZodNativeEnum<T_1>;\n}\nexport interface ZodPromiseDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    type: T;\n    typeName: ZodFirstPartyTypeKind.ZodPromise;\n}\nexport declare class ZodPromise<T extends ZodTypeAny> extends ZodType<Promise<T[\"_output\"]>, ZodPromiseDef<T>, Promise<T[\"_input\"]>> {\n    unwrap(): T;\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: <T_1 extends ZodTypeAny>(schema: T_1, params?: RawCreateParams) => ZodPromise<T_1>;\n}\nexport declare type Refinement<T> = (arg: T, ctx: RefinementCtx) => any;\nexport declare type SuperRefinement<T> = (arg: T, ctx: RefinementCtx) => void;\nexport declare type RefinementEffect<T> = {\n    type: \"refinement\";\n    refinement: (arg: T, ctx: RefinementCtx) => any;\n};\nexport declare type TransformEffect<T> = {\n    type: \"transform\";\n    transform: (arg: T, ctx: RefinementCtx) => any;\n};\nexport declare type PreprocessEffect<T> = {\n    type: \"preprocess\";\n    transform: (arg: T) => any;\n};\nexport declare type Effect<T> = RefinementEffect<T> | TransformEffect<T> | PreprocessEffect<T>;\nexport interface ZodEffectsDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    schema: T;\n    typeName: ZodFirstPartyTypeKind.ZodEffects;\n    effect: Effect<any>;\n}\nexport declare class ZodEffects<T extends ZodTypeAny, Output = output<T>, Input = input<T>> extends ZodType<Output, ZodEffectsDef<T>, Input> {\n    innerType(): T;\n    sourceType(): T;\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    static create: <I extends ZodTypeAny>(schema: I, effect: Effect<I[\"_output\"]>, params?: RawCreateParams) => ZodEffects<I, I[\"_output\"], input<I>>;\n    static createWithPreprocess: <I extends ZodTypeAny>(preprocess: (arg: unknown) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I[\"_output\"], unknown>;\n}\nexport { ZodEffects as ZodTransformer };\nexport interface ZodOptionalDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    innerType: T;\n    typeName: ZodFirstPartyTypeKind.ZodOptional;\n}\nexport declare type ZodOptionalType<T extends ZodTypeAny> = ZodOptional<T>;\nexport declare class ZodOptional<T extends ZodTypeAny> extends ZodType<T[\"_output\"] | undefined, ZodOptionalDef<T>, T[\"_input\"] | undefined> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    unwrap(): T;\n    static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodOptional<T_1>;\n}\nexport interface ZodNullableDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    innerType: T;\n    typeName: ZodFirstPartyTypeKind.ZodNullable;\n}\nexport declare type ZodNullableType<T extends ZodTypeAny> = ZodNullable<T>;\nexport declare class ZodNullable<T extends ZodTypeAny> extends ZodType<T[\"_output\"] | null, ZodNullableDef<T>, T[\"_input\"] | null> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    unwrap(): T;\n    static create: <T_1 extends ZodTypeAny>(type: T_1, params?: RawCreateParams) => ZodNullable<T_1>;\n}\nexport interface ZodDefaultDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    innerType: T;\n    defaultValue: () => util.noUndefined<T[\"_input\"]>;\n    typeName: ZodFirstPartyTypeKind.ZodDefault;\n}\nexport declare class ZodDefault<T extends ZodTypeAny> extends ZodType<util.noUndefined<T[\"_output\"]>, ZodDefaultDef<T>, T[\"_input\"] | undefined> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    removeDefault(): T;\n    static create: <T_1 extends ZodTypeAny>(type: T_1, params: {\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        default: T_1[\"_input\"] | (() => util.noUndefined<T_1[\"_input\"]>);\n    }) => ZodDefault<T_1>;\n}\nexport interface ZodCatchDef<T extends ZodTypeAny = ZodTypeAny> extends ZodTypeDef {\n    innerType: T;\n    catchValue: (ctx: {\n        error: ZodError;\n        input: unknown;\n    }) => T[\"_input\"];\n    typeName: ZodFirstPartyTypeKind.ZodCatch;\n}\nexport declare class ZodCatch<T extends ZodTypeAny> extends ZodType<T[\"_output\"], ZodCatchDef<T>, unknown> {\n    _parse(input: ParseInput): ParseReturnType<this[\"_output\"]>;\n    removeCatch(): T;\n    static create: <T_1 extends ZodTypeAny>(type: T_1, params: {\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        catch: T_1[\"_output\"] | (() => T_1[\"_output\"]);\n    }) => ZodCatch<T_1>;\n}\nexport interface ZodNaNDef extends ZodTypeDef {\n    typeName: ZodFirstPartyTypeKind.ZodNaN;\n}\nexport declare class ZodNaN extends ZodType<number, ZodNaNDef> {\n    _parse(input: ParseInput): ParseReturnType<any>;\n    static create: (params?: RawCreateParams) => ZodNaN;\n}\nexport interface ZodBrandedDef<T extends ZodTypeAny> extends ZodTypeDef {\n    type: T;\n    typeName: ZodFirstPartyTypeKind.ZodBranded;\n}\nexport declare const BRAND: unique symbol;\nexport declare type BRAND<T extends string | number | symbol> = {\n    [BRAND]: {\n        [k in T]: true;\n    };\n};\nexport declare class ZodBranded<T extends ZodTypeAny, B extends string | number | symbol> extends ZodType<T[\"_output\"] & BRAND<B>, ZodBrandedDef<T>, T[\"_input\"]> {\n    _parse(input: ParseInput): ParseReturnType<any>;\n    unwrap(): T;\n}\nexport interface ZodPipelineDef<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodTypeDef {\n    in: A;\n    out: B;\n    typeName: ZodFirstPartyTypeKind.ZodPipeline;\n}\nexport declare class ZodPipeline<A extends ZodTypeAny, B extends ZodTypeAny> extends ZodType<B[\"_output\"], ZodPipelineDef<A, B>, A[\"_input\"]> {\n    _parse(input: ParseInput): ParseReturnType<any>;\n    static create<A extends ZodTypeAny, B extends ZodTypeAny>(a: A, b: B): ZodPipeline<A, B>;\n}\ndeclare type CustomParams = CustomErrorParams & {\n    fatal?: boolean;\n};\nexport declare const custom: <T>(check?: ((data: unknown) => any) | undefined, params?: string | CustomParams | ((input: any) => CustomParams), fatal?: boolean | undefined) => ZodType<T, ZodTypeDef, T>;\nexport { ZodType as Schema, ZodType as ZodSchema };\nexport declare const late: {\n    object: <T extends ZodRawShape>(shape: () => T, params?: RawCreateParams) => ZodObject<T, \"strip\", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<baseObjectOutputType<T>, { [k in keyof baseObjectOutputType<T>]: undefined extends baseObjectOutputType<T>[k] ? never : k; }[keyof T]>]: objectUtil.addQuestionMarks<baseObjectOutputType<T>, { [k in keyof baseObjectOutputType<T>]: undefined extends baseObjectOutputType<T>[k] ? never : k; }[keyof T]>[k_1]; }, { [k_2 in keyof baseObjectInputType<T>]: baseObjectInputType<T>[k_2]; }>;\n};\nexport declare enum ZodFirstPartyTypeKind {\n    ZodString = \"ZodString\",\n    ZodNumber = \"ZodNumber\",\n    ZodNaN = \"ZodNaN\",\n    ZodBigInt = \"ZodBigInt\",\n    ZodBoolean = \"ZodBoolean\",\n    ZodDate = \"ZodDate\",\n    ZodSymbol = \"ZodSymbol\",\n    ZodUndefined = \"ZodUndefined\",\n    ZodNull = \"ZodNull\",\n    ZodAny = \"ZodAny\",\n    ZodUnknown = \"ZodUnknown\",\n    ZodNever = \"ZodNever\",\n    ZodVoid = \"ZodVoid\",\n    ZodArray = \"ZodArray\",\n    ZodObject = \"ZodObject\",\n    ZodUnion = \"ZodUnion\",\n    ZodDiscriminatedUnion = \"ZodDiscriminatedUnion\",\n    ZodIntersection = \"ZodIntersection\",\n    ZodTuple = \"ZodTuple\",\n    ZodRecord = \"ZodRecord\",\n    ZodMap = \"ZodMap\",\n    ZodSet = \"ZodSet\",\n    ZodFunction = \"ZodFunction\",\n    ZodLazy = \"ZodLazy\",\n    ZodLiteral = \"ZodLiteral\",\n    ZodEnum = \"ZodEnum\",\n    ZodEffects = \"ZodEffects\",\n    ZodNativeEnum = \"ZodNativeEnum\",\n    ZodOptional = \"ZodOptional\",\n    ZodNullable = \"ZodNullable\",\n    ZodDefault = \"ZodDefault\",\n    ZodCatch = \"ZodCatch\",\n    ZodPromise = \"ZodPromise\",\n    ZodBranded = \"ZodBranded\",\n    ZodPipeline = \"ZodPipeline\"\n}\nexport declare type ZodFirstPartySchemaTypes = ZodString | ZodNumber | ZodNaN | ZodBigInt | ZodBoolean | ZodDate | ZodUndefined | ZodNull | ZodAny | ZodUnknown | ZodNever | ZodVoid | ZodArray<any, any> | ZodObject<any, any, any> | ZodUnion<any> | ZodDiscriminatedUnion<any, any> | ZodIntersection<any, any> | ZodTuple<any, any> | ZodRecord<any, any> | ZodMap<any> | ZodSet<any> | ZodFunction<any, any> | ZodLazy<any> | ZodLiteral<any> | ZodEnum<any> | ZodEffects<any, any, any> | ZodNativeEnum<any> | ZodOptional<any> | ZodNullable<any> | ZodDefault<any> | ZodCatch<any> | ZodPromise<any> | ZodBranded<any, any> | ZodPipeline<any, any>;\ndeclare abstract class Class {\n    constructor(..._: any[]);\n}\ndeclare const instanceOfType: <T extends typeof Class>(cls: T, params?: CustomParams) => ZodType<InstanceType<T>, ZodTypeDef, InstanceType<T>>;\ndeclare const stringType: (params?: ({\n    errorMap?: ZodErrorMap | undefined;\n    invalid_type_error?: string | undefined;\n    required_error?: string | undefined;\n    description?: string | undefined;\n} & {\n    coerce?: true | undefined;\n}) | undefined) => ZodString;\ndeclare const numberType: (params?: ({\n    errorMap?: ZodErrorMap | undefined;\n    invalid_type_error?: string | undefined;\n    required_error?: string | undefined;\n    description?: string | undefined;\n} & {\n    coerce?: boolean | undefined;\n}) | undefined) => ZodNumber;\ndeclare const nanType: (params?: RawCreateParams) => ZodNaN;\ndeclare const bigIntType: (params?: ({\n    errorMap?: ZodErrorMap | undefined;\n    invalid_type_error?: string | undefined;\n    required_error?: string | undefined;\n    description?: string | undefined;\n} & {\n    coerce?: boolean | undefined;\n}) | undefined) => ZodBigInt;\ndeclare const booleanType: (params?: ({\n    errorMap?: ZodErrorMap | undefined;\n    invalid_type_error?: string | undefined;\n    required_error?: string | undefined;\n    description?: string | undefined;\n} & {\n    coerce?: boolean | undefined;\n}) | undefined) => ZodBoolean;\ndeclare const dateType: (params?: ({\n    errorMap?: ZodErrorMap | undefined;\n    invalid_type_error?: string | undefined;\n    required_error?: string | undefined;\n    description?: string | undefined;\n} & {\n    coerce?: boolean | undefined;\n}) | undefined) => ZodDate;\ndeclare const symbolType: (params?: RawCreateParams) => ZodSymbol;\ndeclare const undefinedType: (params?: RawCreateParams) => ZodUndefined;\ndeclare const nullType: (params?: RawCreateParams) => ZodNull;\ndeclare const anyType: (params?: RawCreateParams) => ZodAny;\ndeclare const unknownType: (params?: RawCreateParams) => ZodUnknown;\ndeclare const neverType: (params?: RawCreateParams) => ZodNever;\ndeclare const voidType: (params?: RawCreateParams) => ZodVoid;\ndeclare const arrayType: <T extends ZodTypeAny>(schema: T, params?: RawCreateParams) => ZodArray<T, \"many\">;\ndeclare const objectType: <T extends ZodRawShape>(shape: T, params?: RawCreateParams) => ZodObject<T, \"strip\", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<baseObjectOutputType<T>, { [k in keyof baseObjectOutputType<T>]: undefined extends baseObjectOutputType<T>[k] ? never : k; }[keyof T]>]: objectUtil.addQuestionMarks<baseObjectOutputType<T>, { [k in keyof baseObjectOutputType<T>]: undefined extends baseObjectOutputType<T>[k] ? never : k; }[keyof T]>[k_1]; }, { [k_2 in keyof baseObjectInputType<T>]: baseObjectInputType<T>[k_2]; }>;\ndeclare const strictObjectType: <T extends ZodRawShape>(shape: T, params?: RawCreateParams) => ZodObject<T, \"strict\", ZodTypeAny, { [k_1 in keyof objectUtil.addQuestionMarks<baseObjectOutputType<T>, { [k in keyof baseObjectOutputType<T>]: undefined extends baseObjectOutputType<T>[k] ? never : k; }[keyof T]>]: objectUtil.addQuestionMarks<baseObjectOutputType<T>, { [k in keyof baseObjectOutputType<T>]: undefined extends baseObjectOutputType<T>[k] ? never : k; }[keyof T]>[k_1]; }, { [k_2 in keyof baseObjectInputType<T>]: baseObjectInputType<T>[k_2]; }>;\ndeclare const unionType: <T extends readonly [ZodTypeAny, ZodTypeAny, ...ZodTypeAny[]]>(types: T, params?: RawCreateParams) => ZodUnion<T>;\ndeclare const discriminatedUnionType: typeof ZodDiscriminatedUnion.create;\ndeclare const intersectionType: <T extends ZodTypeAny, U extends ZodTypeAny>(left: T, right: U, params?: RawCreateParams) => ZodIntersection<T, U>;\ndeclare const tupleType: <T extends [] | [ZodTypeAny, ...ZodTypeAny[]]>(schemas: T, params?: RawCreateParams) => ZodTuple<T, null>;\ndeclare const recordType: typeof ZodRecord.create;\ndeclare const mapType: <Key extends ZodTypeAny = ZodTypeAny, Value extends ZodTypeAny = ZodTypeAny>(keyType: Key, valueType: Value, params?: RawCreateParams) => ZodMap<Key, Value>;\ndeclare const setType: <Value extends ZodTypeAny = ZodTypeAny>(valueType: Value, params?: RawCreateParams) => ZodSet<Value>;\ndeclare const functionType: typeof ZodFunction.create;\ndeclare const lazyType: <T extends ZodTypeAny>(getter: () => T, params?: RawCreateParams) => ZodLazy<T>;\ndeclare const literalType: <T extends Primitive>(value: T, params?: RawCreateParams) => ZodLiteral<T>;\ndeclare const enumType: typeof createZodEnum;\ndeclare const nativeEnumType: <T extends EnumLike>(values: T, params?: RawCreateParams) => ZodNativeEnum<T>;\ndeclare const promiseType: <T extends ZodTypeAny>(schema: T, params?: RawCreateParams) => ZodPromise<T>;\ndeclare const effectsType: <I extends ZodTypeAny>(schema: I, effect: Effect<I[\"_output\"]>, params?: RawCreateParams) => ZodEffects<I, I[\"_output\"], input<I>>;\ndeclare const optionalType: <T extends ZodTypeAny>(type: T, params?: RawCreateParams) => ZodOptional<T>;\ndeclare const nullableType: <T extends ZodTypeAny>(type: T, params?: RawCreateParams) => ZodNullable<T>;\ndeclare const preprocessType: <I extends ZodTypeAny>(preprocess: (arg: unknown) => unknown, schema: I, params?: RawCreateParams) => ZodEffects<I, I[\"_output\"], unknown>;\ndeclare const pipelineType: typeof ZodPipeline.create;\ndeclare const ostring: () => ZodOptional<ZodString>;\ndeclare const onumber: () => ZodOptional<ZodNumber>;\ndeclare const oboolean: () => ZodOptional<ZodBoolean>;\nexport declare const coerce: {\n    string: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: true | undefined;\n    }) | undefined) => ZodString;\n    number: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodNumber;\n    boolean: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodBoolean;\n    bigint: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodBigInt;\n    date: (params?: ({\n        errorMap?: ZodErrorMap | undefined;\n        invalid_type_error?: string | undefined;\n        required_error?: string | undefined;\n        description?: string | undefined;\n    } & {\n        coerce?: boolean | undefined;\n    }) | undefined) => ZodDate;\n};\nexport { anyType as any, arrayType as array, bigIntType as bigint, booleanType as boolean, dateType as date, discriminatedUnionType as discriminatedUnion, effectsType as effect, enumType as enum, functionType as function, instanceOfType as instanceof, intersectionType as intersection, lazyType as lazy, literalType as literal, mapType as map, nanType as nan, nativeEnumType as nativeEnum, neverType as never, nullType as null, nullableType as nullable, numberType as number, objectType as object, oboolean, onumber, optionalType as optional, ostring, pipelineType as pipeline, preprocessType as preprocess, promiseType as promise, recordType as record, setType as set, strictObjectType as strictObject, stringType as string, symbolType as symbol, effectsType as transformer, tupleType as tuple, undefinedType as undefined, unionType as union, unknownType as unknown, voidType as void, };\nexport declare const NEVER: never;\n","filePath":"file:///node_modules/@types/zod/types.d.ts"},{"content":"import { AllTypes } from './type'\nimport type { Mutable } from './utils'\n\n/**\n * 为了设置 wrap 的默认值\n *\n * 在其他对应 control 组件中引入该变量，并 push 将其默认设置为 wrap 换行模式\n * 该种默认设置后，可以通过传入 `no-wrap` 使得其不换行\n * 例如：\n * ```js\n * import { NeedWrapModes } from 'zodui-react'\n * NeedWrapModes.push('code', /^code/)\n * ```\n */\nexport const WrapModes: (string | RegExp)[] = []\n\n/**\n * 复合 schema 的类型\n */\nexport const ComplexMultipleTypes = [AllTypes.ZodTuple, AllTypes.ZodObject]\n\n/**\n * 可修改 key 的值的类型\n */\nexport const KeyEditableTypes = [AllTypes.ZodRecord, AllTypes.ZodMap]\n\nconst innerMonad = [\n  AllTypes.ZodString,\n  AllTypes.ZodNumber,\n  AllTypes.ZodBoolean,\n  AllTypes.ZodDate\n] as const\n\nexport const monad = innerMonad as Mutable<typeof innerMonad>\n\nexport type MonadType = (typeof monad)[number]\n\nconst innerComplexTypes = [\n  AllTypes.ZodUnion,\n  AllTypes.ZodDiscriminatedUnion\n] as const\n\nexport const complex = innerComplexTypes as Mutable<typeof innerComplexTypes>\n\nexport type ComplexType = (typeof complex)[number]\n\nconst innerMultipleTypes = [\n  AllTypes.ZodArray,\n  AllTypes.ZodTuple,\n  AllTypes.ZodSet,\n  AllTypes.ZodMap,\n  AllTypes.ZodRecord,\n  AllTypes.ZodObject\n] as const\n\nexport const multiple = innerMultipleTypes as Mutable<typeof innerMultipleTypes>\n\nexport type MultipleType = (typeof multiple)[number]\n","filePath":"file:///node_modules/@types/@zodui/core/configure.ts"},{"content":"import type { DefineUnit } from './createDefineUnit'\nimport { createDefineUnit } from './createDefineUnit'\nimport type { FrameworkKeys, Plugin } from './plugin'\nimport { Framework } from './plugin'\n\nconst effectSymbol = Symbol('effect')\n\nclass Emitter {\n  #listeners = new Map<string, Function[]>()\n  on(key: string, func: Function) {\n    const list = this.#listeners.get(key) || []\n    const index = list.length\n    list.push(func)\n    this.#listeners.set(key, list)\n    return () => {\n      list.splice(index, 1)\n      this.#listeners.set(key, list)\n    }\n  }\n  do(...args: any[]) {\n    const [key, ...params] = args\n    const list = this.#listeners.get(key) || []\n    list.forEach(func => func(...params))\n  }\n}\n\n/**\n * Contexts extended by the same Context share the same store\n * The `extend` method is used to record the side effects of the next operation\n * When you need to reclaim the side effects of this segment, you only need to call the off function,\n * or execute the functions from `[effectSymbol]` filed\n */\nexport class Context<\n  PluginName extends string = string\n> {\n  static global = new Context()\n    // eslint-disable-next-line indent\n  ;[effectSymbol]: Function[] = []\n  defineUnit: DefineUnit<PluginName>\n  constructor(\n    private readonly store = new Map<string, any>(),\n    private readonly emitter = new Emitter()\n  ) {\n    this.defineUnit = createDefineUnit(this)\n  }\n  extend() {\n    return new Context(this.store, this.emitter)\n  }\n  set(k: string, v?: any) {\n    this.store?.set(k, v)\n    this.emitter.do(k, v)\n    this[effectSymbol].push(() => {\n      const storeV = this.store?.get(k)\n      if (storeV === v) {\n        this.store?.delete(k)\n      }\n    })\n    return this\n  }\n  upd<T>(k: string, func: (v: T) => T | Promise<T>, effect: (v: T) => T | Promise<T>) {\n    const newValue = func(this.store?.get(k))\n    this.store?.set(k, newValue)\n    this.emitter.do(k, newValue)\n    this[effectSymbol].push(() => {\n      this.store?.set(k, effect(this.store?.get(k)))\n    })\n    return this\n  }\n  del(k: string) {\n    const storeV = this.store?.get(k)\n    this.store?.delete(k)\n    this.emitter.do(k)\n    this[effectSymbol].push(() => {\n      this.store?.set(k, storeV)\n    })\n    return this\n  }\n  get<T>(k: string) {\n    return [\n      this.store?.get(k) as T,\n      this.emitter.on.bind(this.emitter, k)\n    ] as const\n  }\n  use(p: Plugin | (() => Promise<Plugin>) | (() => Promise<{ default: Plugin }>)) {\n    let effect: Function\n\n    const childCtx = this.extend()\n    function collectPluginEffect(p: Plugin) {\n      p.call(childCtx)\n      effect = () => {\n        childCtx[effectSymbol].forEach(func => func())\n      }\n    }\n    if (typeof p === 'function') {\n      const promise = p()\n      if (promise instanceof Promise) {\n        let isCancel = false\n        promise\n          .then(plugin => {\n            if (isCancel) return\n            // let default field prioritize\n            if (plugin.default) {\n              plugin = plugin.default\n            }\n            collectPluginEffect(plugin)\n          })\n        effect = () => {\n          isCancel = true\n        }\n      } else {\n        throw new Error('plugin must be a function or a promise')\n      }\n    } else {\n      collectPluginEffect(p)\n    }\n\n    // make effect function closure for store this reference\n    const wrapEffect = () => effect()\n    this[effectSymbol].push(wrapEffect)\n    return wrapEffect\n  }\n  framework<K extends FrameworkKeys>(key: K): Framework<K, PluginName> {\n    return new Framework(key, this)\n  }\n}\n","filePath":"file:///node_modules/@types/@zodui/core/context.ts"},{"content":"import type { Context } from './context'\nimport type { Framework, FrameworkKeys, Matcher, UnitMap, UnitProps } from './plugin'\nimport type { AllType, TypeMap } from './type'\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nexport interface UnitFrameworksComp<\n  N extends keyof UnitMap = keyof UnitMap,\n  Props = {}\n> {\n/* eslint-enable @typescript-eslint/no-unused-vars */\n  [key: FrameworkKeys]: unknown\n}\n\nexport interface DefineUnit<\n  PluginName extends string = string,\n  FK extends FrameworkKeys = never,\n  This = [FK] extends [never]\n    ? Context<PluginName>\n    : Framework<FK, PluginName>\n> {\n  <\n    N extends keyof UnitMap,\n    T extends AllType\n  >(\n    this: This,\n    name: N,\n    types: T[],\n    matchers: Matcher<\n      [FK] extends [never] ? never : UnitFrameworksComp<\n        N,\n        & Omit<UnitProps<T, TypeMap[T]>, keyof UnitMap[N]['props']>\n        & UnitMap[N]['props']\n      >[FK],\n      N,\n      T\n    >[]\n  ): This\n  composer<T extends AllType>(this: This, types: T[], matchers: Matcher[]): This\n  switcher<T extends AllType>(this: This, types: T[], matchers: Matcher[]): This\n}\n\nexport function createDefineUnit<\n  PluginName extends string = string,\n  FK extends FrameworkKeys = never,\n  This = FK extends never\n    ? Context<PluginName>\n    : Framework<FK, PluginName>\n>(\n  ctx: Context<PluginName>,\n  framework?: Framework<FK>\n) {\n  type DU = DefineUnit<PluginName, FK, This>\n  const innerThis = (framework ?? ctx) as This\n  const prevKey = framework ? `framework.${framework.key}.units` : `units`\n  let du = function (name, types, matchers) {\n    const keys = types.map(type => `${prevKey}.${name}.${type}`)\n\n    keys.forEach(k => {\n      ctx.upd<typeof matchers>(\n        k, (list = []) => {\n          return list.concat(matchers)\n        }, list => {\n          return list.filter(m => !matchers.includes(m))\n        }\n      )\n    })\n    return this\n  } as DU\n  // bind will lose fields, so we need bind ctx when create du\n  // bind type infer is not good, so we need to use `as` to fix it\n  du = du.bind(innerThis) as DU\n  du.composer = function () {\n    // TODO set it to store\n    return this\n  }\n  du.composer = du.composer.bind(innerThis)\n  du.switcher = function () {\n    // TODO set it to store\n    return this\n  }\n  du.switcher = du.switcher.bind(innerThis)\n  return du\n}\n","filePath":"file:///node_modules/@types/@zodui/core/createDefineUnit.ts"},{"content":"import type { ModesMap } from '@zodui/core'\nimport type { Schema, ZodDefaultDef, ZodObject, ZodRawShape, ZodTypeAny } from 'zod'\nimport * as z from 'zod'\n\ndeclare module 'zod' {\n  export interface ZodTypeDef {\n    mode: string\n    label: string\n  }\n  export interface ZodType<Output = any, Def extends ZodTypeDef = ZodTypeDef, Input = Output> {\n    readonly _mode: string\n    // TODO support generic\n    // mode<T extends string>(\n    mode(\n      mode:\n        | Def extends ZodDefaultDef<infer InnerT extends ZodTypeAny>\n          ? ModesMap[InnerT['_def']['typeName']]\n          // @ts-ignore\n          : ModesMap[Def['typeName']]\n        | (string & {})\n    ): ZodType<Output, Def, Input>\n\n    readonly _label: string\n    label(mode: string): ZodType<Output, Def, Input>\n\n    readonly type: string\n  }\n  export function clazz<T>(clazz: { new(): T }): Schema<T>\n  export function asObject<T>(t: T): ZodObject<Record<string, ZodTypeAny> & T>\n  // TODO resolve default type\n}\n\nfunction defineMetaField(key: string) {\n  try {\n    !Object.hasOwn(z.ZodType.prototype, `_${key}`)\n      && Object.defineProperty(z.ZodType.prototype, `_${key}`, {\n        get() {\n          return this._def[key]\n        }\n      })\n    !Object.hasOwn(z.ZodType.prototype, key)\n      && Object.defineProperty(z.ZodType.prototype, key, {\n        get() {\n          return (val: any) => {\n            const This = (this as any).constructor\n            return new This({\n              ...this._def,\n              [key]: val\n            })\n          }\n        }\n      })\n  } catch (e) {\n    console.error(e)\n  }\n}\n\ndefineMetaField('mode')\ndefineMetaField('label')\n\n!Object.hasOwn(z.ZodType.prototype, 'type')\n  && Object.defineProperty(z.ZodType.prototype, 'type', {\n    get() {\n      return this._def\n        ?.typeName\n        .replace('Zod', '')\n        .toLowerCase()\n        ?? 'unknown'\n    }\n  })\n\nconst nz = { ...z } as typeof z\n\nexport default nz\n\nexport function clazz<T extends ZodRawShape>(clazz: { new(): T }): Schema<T> {\n  return z.object(new clazz()) as any\n}\n// @ts-ignore\nnz.clazz = clazz\n\nexport function asObject<T extends ZodRawShape>(t: T): ZodObject<Record<string, ZodTypeAny> & T> {\n  return z.object(t) as any\n}\n// @ts-ignore\nnz.asObject = asObject\n\nexport { nz as z }\n\nexport * from 'zod'\n","filePath":"file:///node_modules/@types/@zodui/core/external.ts"},{"content":"export * from './configure'\nexport * from './context'\nexport * from './createDefineUnit'\nexport * from './plugin'\nexport * from './type'\n","filePath":"file:///node_modules/@types/@zodui/core/index.ts"},{"content":"import type { AllType, ModesMap } from '@zodui/core'\nimport type { Schema as ZodSchema, TypeOf } from 'zod'\n\nexport interface SchemaResolver<\n  M extends ZodSchema,\n  V = TypeOf<M>\n> {\n  disabled?: boolean\n  model: M\n  value?: V\n  defaultValue?: V\n  onChange?: (value: V) => void | Promise<void>\n}\n\nexport interface ComposerRef<\n  M extends ZodSchema = any,\n  V = TypeOf<M>\n> {\n  /**\n   * Reset the composer to the default value of the model and its properties.\n   */\n  reset: () => void\n  /**\n   * Verify the composer and return the value.\n   */\n  verify: () => Promise<V>\n  watch: {\n    (): V\n    <K extends keyof V>(key: K): V[K]\n    <K extends keyof V>(key: K, callback: (value: V[K]) => void): void\n  }\n  values: V\n}\n\nexport interface ComposerProps<M extends ZodSchema> extends SchemaResolver<M> {\n  prefix?: string\n}\n\nexport interface DescriptorRef {\n  verify: () => Promise<any>\n}\n\nexport interface DescriptorProps<M extends ZodSchema> extends SchemaResolver<M> {\n  uKey?: string\n  meta: {\n    label: string\n    description?: string\n  }\n}\n\nexport interface SwitcherProps<M extends ZodSchema> extends SchemaResolver<M> {\n  uKey?: string\n  modes?: string[]\n}\n\nexport interface UnitProps<T extends AllType, M extends ZodSchema> extends SchemaResolver<M> {\n  uKey?: string\n  // @ts-ignore\n  modes?: (ModesMap[T] | (string & {}))[]\n}\n","filePath":"file:///node_modules/@types/@zodui/core/plugin/base.ts"},{"content":"import type { FrameworkKeys } from './framework'\n\nexport type Icons =\n  | 'Add'\n  | 'More'\n  | 'Link'\n  | 'Clear'\n  | 'Delete'\n  | 'Append'\n  | 'Prepend'\n  | 'ArrowUp'\n  | 'ArrowDown'\n\nexport interface FrameworkComponents {\n  [key: string]: {\n    [K in FrameworkKeys]: any\n  }\n}\n\nexport namespace ComponentProps {\n  export type Option = {\n    label?: string\n    title?: string\n    value: string | number\n    disabled?: boolean\n  }\n  export type InputValue = string | number | undefined\n  export type Input<T extends InputValue = InputValue> =\n    & {\n      type?: 'text' | 'password' | 'number' | 'email' | 'tel' | 'url' | 'search'\n      value?: T\n      defaultValue?: T\n      onChange?: (v: T) => void\n    }\n    & ({\n      mode?: string\n    } | {\n      type?: 'number'\n      mode?: 'split'\n    })\n  export type InputAdornment = {\n    prev?: any\n    next?: any\n  }\n  export type Button = {\n    icon?: any\n    theme?: 'error' | 'warning' | 'success' | 'info'\n    shape?: 'square' | 'round' | 'circle'\n    variant?: 'text' | 'outline'\n    onClick?: () => void\n  }\n  export type SelectValue = string | number | undefined | (string | number)[]\n  export type SelectOption = Option\n  // TODO support input select\n  // TODO support multiple select\n  export type Select<T extends SelectValue> = {\n    options?: SelectOption[]\n    value?: T\n    defaultValue?: T\n    onChange?: (v: T) => void\n  }\n  export type Switch = {\n    value?: boolean\n    defaultValue?: boolean\n    onChange?: (v: boolean) => void\n  }\n  export type DropdownMenuItem = {\n    icon?: any\n    label: any\n    title?: string\n    value?: string | number\n    disabled?: boolean\n  }\n  export type Dropdown = {\n    trigger?: 'hover' | 'click'\n    placement?: 'right'\n    menu: DropdownMenuItem[]\n    children?: any\n    onAction?: (value: string | number, item: DropdownMenuItem) => void\n  }\n  export type RadioGroupValue = string | number | undefined\n  export type RadioGroupOption = Option\n  export type RadioGroup<T extends RadioGroupValue> = {\n    variant?: 'outline' | 'card'\n    /**\n     * @default {'row'}\n     */\n    direction?: 'row' | 'column'\n    options?: RadioGroupOption[]\n    value?: T\n    defaultValue?: T\n    onChange?: (v: T) => void\n  }\n  // RadioGroup: () => <></>\n  // Dialog: () => <></>\n  // Drawer: () => <></>\n}\n","filePath":"file:///node_modules/@types/@zodui/core/plugin/components.ts"},{"content":"import type { Context } from '../context'\nimport type { DefineUnit } from '../createDefineUnit'\nimport { createDefineUnit } from '../createDefineUnit'\nimport type { TypeMap } from '../type'\nimport type { SwitcherProps } from './base'\nimport type { Icons } from './components'\n\nconst PropsSymbol = Symbol('props')\n\nexport type AsProps<T = {}> = T & { [PropsSymbol]: unknown }\n\nexport interface RenderPropsMap {\n}\n\ninterface BuiltinRenderPropsMap {\n  Array: Record<string, AsProps<SwitcherProps<TypeMap['ZodArray']>>>\n  Color: Record<string, AsProps<SwitcherProps<TypeMap['ZodString']>>>\n  String: Record<string, AsProps<SwitcherProps<TypeMap['ZodString']>>>\n  Number: Record<string, AsProps<SwitcherProps<TypeMap['ZodNumber']>>>\n  Boolean: Record<string, AsProps<SwitcherProps<TypeMap['ZodBoolean']>>>\n  Date: Record<string, AsProps<SwitcherProps<TypeMap['ZodDate']>>>\n  Range: Record<string, AsProps<SwitcherProps<TypeMap['ZodTuple']>>>\n}\n\ntype CalcPropsMap<Map> = {\n  [K in keyof Map]: K extends keyof BuiltinRenderPropsMap\n    ? {\n      [KK in keyof Map[K]]: BuiltinRenderPropsMap[K][string] & Map[K][KK]\n    }\n    : {}\n}\n\nexport type InnerRenderPropsMap<Map = {}> =\n  & BuiltinRenderPropsMap\n  & CalcPropsMap<RenderPropsMap>\n  & CalcPropsMap<Map>\n\nexport type CalcPaths<Map = RenderPropsMap, PrevK extends string = never> = Map extends AsProps\n  ? PrevK\n  : {\n    [K in (keyof Map & string)]:\n      | [K] extends [never] ? never : PrevK\n      | CalcPaths<Map[K], [PrevK] extends [never] ? K : `${PrevK}${\n        // Equal\n        (<G>() => G extends K ? 1 : 2) extends (<G>() => G extends string ? 1 : 2)\n          ? `.${K}`\n          : `:${K}`\n      }`>\n  }[keyof Map & string]\n\nexport type AllPaths<M> = CalcPaths<M> | CalcPaths<BuiltinRenderPropsMap>\n\nexport type RevealPropsByPath<\n  Path extends string,\n  Map = InnerRenderPropsMap\n> = Path extends `${infer Key}${'.' | ':'}${infer Rest}`\n  ? Key extends keyof Map\n    ? Map[Key] extends Record<string, any>\n      ? RevealPropsByPath<Rest, Map[Key]>\n      : never\n    : never\n  : Path extends keyof Map\n    ? Map[Path] extends AsProps\n      ? Map[Path]\n      : Map[Path] extends Record<string, any>\n        ? Map[Path][string]\n        : never\n    : never\n\nexport class Framework<\n  K extends FrameworkKeys,\n  N extends string = string,\n  Components = Frameworks[K]['Components'],\n  Renders = Frameworks[K]['Renders']\n> {\n  defineUnit: DefineUnit<N, K>\n  constructor(\n    public readonly key: K,\n    private readonly ctx: Context<N>\n  ) {\n    this.defineUnit = createDefineUnit(ctx, this)\n  }\n  defineComp<\n    Type extends keyof Components & string,\n  >(\n    type: Type, Component: Components[Type]\n  ) {\n    this.ctx.set(`framework.${this.key}.components.${type}`, Component)\n    return this\n  }\n  defineIcon<\n    Icon extends Icons\n  >(\n    icon: Icon,\n    Comp: Frameworks[K]['Icon']\n  ) {\n    this.ctx.set(`framework.${this.key}.icons.${icon}`, Comp)\n    return this\n  }\n  defineRender<\n    P extends AllPaths<RenderPropsMap & Renders>,\n    InnerProps = RevealPropsByPath<P, InnerRenderPropsMap<Renders>>,\n    Props = InnerProps extends AsProps<infer P> ? P : never\n  >(path: P | (string & {}), Ctrl: FrameworkRndr<Props>[K]) {\n    this.ctx.set(`framework.${this.key}.rndrs.${path}`, Ctrl)\n    return this\n  }\n  defineRndr = this.defineRender\n}\n\nexport interface Frameworks {\n  [key: string]: {\n    Icon: any\n    Renders: {}\n    /**\n     * define framework special component func value to infer defineComp func type\n     */\n    Components: Record<string, any>\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport interface FrameworkRndr<Props> {\n  [key: string]: any\n}\n\nexport type FrameworkKeys = keyof Frameworks & string\n","filePath":"file:///node_modules/@types/@zodui/core/plugin/framework.ts"},{"content":"import type { Context } from '../context'\nimport type { AllType, TypeMap } from '../type'\nimport type { UnitProps } from './base'\nimport type { ComponentProps } from './components'\n\nexport * from './base'\nexport type {\n  ComponentProps,\n  FrameworkComponents,\n  Icons\n} from './components'\nexport * from './framework'\n\ntype Rule<N extends keyof UnitMap> =\n  | string[]\n  | [N] extends [never]\n    ? { (modes: string[]): boolean }\n    : { (modes: string[], opts?: UnitMap[N]['options']): boolean }\n\nexport type PropsResolver<\n  N extends keyof UnitMap = never,\n  T extends AllType = never\n> = Record<string, any> | ((\n  props:\n    & Omit<UnitProps<T, TypeMap[T]>, keyof UnitMap[N]['props']>\n    & UnitMap[N]['props']\n) => Record<string, any>)\n\ntype MatcherRndr<\n  C,\n  N extends keyof UnitMap = never,\n  T extends AllType = never\n> =\n  | string\n  | (\n    [C] extends [never]\n      // When the component is not set, returns a function that takes props and returns a component Rndr String and its props\n      ? ((\n        opts:\n          & { modes: string[] }\n          & { modelType: T }\n          & UnitMap[N]['options']\n      // TODO infer rndr props by target\n      ) => [rndrTarget: string, rndrProps: PropsResolver<N, T>])\n      : C\n  )\n  | [rndrTarget: string, rndrProps: PropsResolver<N, T>]\n\nexport type Matcher<\n  C = never,\n  N extends keyof UnitMap = never,\n  T extends AllType = never\n> =\n  | [rule: Rule<N>, rndr: MatcherRndr<C, N, T>]\n\n// export interface UnitMap<\n//   // TODO support get value type from generic by higher order function\n//   // M extends ZodSchema = any,\n//   // V = TypeOf<M>\n// > {\nexport interface UnitMap {\n  [key: string]: {\n    props: unknown\n    options: unknown\n  }\n  monad: {\n    props: {\n    }\n    options: {}\n  }\n  complex: {\n    props: {\n      options: ComponentProps.Option[]\n      OptionRender: any\n    }\n    options: {\n      model: TypeMap[AllType]\n    }\n  }\n  multiple: {\n    props: {\n      schemas: TypeMap[AllType][]\n      onChange?: (value: any[]) => void | Promise<void>\n    }\n    options: {\n      schemas: TypeMap[AllType][]\n    }\n  }\n}\n\nexport interface Plugin<N extends string = string> {\n  name: N\n  call: (ctx: Context) => void\n}\n\nexport function definePlugin(\n  name: Plugin['name'],\n  call: Plugin['call']\n): Plugin {\n  return { name, call }\n}\n","filePath":"file:///node_modules/@types/@zodui/core/plugin/index.ts"},{"content":"import type { ZodRawShape, ZodUnionOptions } from 'zod'\nimport type z from 'zod'\nimport { ZodFirstPartyTypeKind } from 'zod'\n\ntype IsEqual<A, B> = (\n  <T>() => T extends A ? 1 : 2\n) extends (\n  <T>() => T extends B ? 1 : 2\n) ? true : false\n\nexport interface ZodTypeMap<\n  /* eslint-disable @typescript-eslint/no-unnecessary-type-constraint, @typescript-eslint/no-unused-vars */\n  A extends any = any,\n  B extends any = any,\n  C extends any = any,\n  D extends any = any,\n  E extends any = any\n  /* eslint-enable @typescript-eslint/no-unnecessary-type-constraint, @typescript-eslint/no-unused-vars */\n> {\n  ZodString: z.ZodString\n  ZodNumber: z.ZodNumber\n  ZodNaN: z.ZodNaN\n  ZodBigInt: z.ZodBigInt\n  ZodBoolean: z.ZodBoolean\n  ZodDate: z.ZodDate\n  ZodSymbol: z.ZodSymbol\n  ZodUndefined: z.ZodUndefined\n  ZodNull: z.ZodNull\n  ZodAny: z.ZodAny\n  ZodUnknown: z.ZodUnknown\n  ZodNever: z.ZodNever\n  ZodVoid: z.ZodVoid\n  // FIXME\n  ZodArray: z.ZodArray<A>\n  ZodObject: z.ZodObject<\n    IsEqual<A, any> extends true\n      ? ZodRawShape\n      : A\n  >\n  ZodUnion: z.ZodUnion<ZodUnionOptions>\n  ZodDiscriminatedUnion: z.ZodDiscriminatedUnion<A, B>\n  ZodIntersection: z.ZodIntersection<A, B>\n  ZodTuple: z.ZodTuple\n  ZodRecord: z.ZodRecord\n  ZodMap: z.ZodMap\n  ZodSet: z.ZodSet\n  ZodFunction: z.ZodFunction<A, B>\n  ZodLazy: z.ZodLazy<A>\n  ZodLiteral: z.ZodLiteral<A>\n  ZodEnum: z.ZodEnum<A>\n  ZodEffects: z.ZodEffects<A>\n  ZodNativeEnum: z.ZodNativeEnum<A>\n  ZodOptional: z.ZodOptional<A>\n  ZodNullable: z.ZodNullable<A>\n  ZodDefault: z.ZodDefault<A>\n  ZodCatch: z.ZodCatch<A>\n  ZodPromise: z.ZodPromise<A>\n  ZodBranded: z.ZodBranded<A, B>\n  ZodPipeline: z.ZodPipeline<A, B>\n}\n\nexport interface ZodTypeDefMap<\n  /* eslint-disable @typescript-eslint/no-unnecessary-type-constraint, @typescript-eslint/no-unused-vars */\n  A extends any = any,\n  B extends any = any,\n  C extends any = any,\n  D extends any = any,\n  E extends any = any\n  /* eslint-enable @typescript-eslint/no-unnecessary-type-constraint, @typescript-eslint/no-unused-vars */\n> {\n  ZodString: z.ZodStringDef\n  ZodNumber: z.ZodNumberDef\n  ZodNaN: z.ZodNaNDef\n  ZodBigInt: z.ZodBigIntDef\n  ZodBoolean: z.ZodBooleanDef\n  ZodDate: z.ZodDateDef\n  ZodSymbol: z.ZodSymbolDef\n  ZodUndefined: z.ZodUndefinedDef\n  ZodNull: z.ZodNullDef\n  ZodAny: z.ZodAnyDef\n  ZodUnknown: z.ZodUnknownDef\n  ZodNever: z.ZodNeverDef\n  ZodVoid: z.ZodVoidDef\n  ZodArray: z.ZodArrayDef\n  ZodObject: z.ZodObjectDef\n  ZodUnion: z.ZodUnionDef\n  ZodDiscriminatedUnion: z.ZodDiscriminatedUnionDef<A>\n  ZodIntersection: z.ZodIntersectionDef\n  ZodTuple: z.ZodTupleDef\n  ZodRecord: z.ZodRecordDef\n  ZodMap: z.ZodMapDef\n  ZodSet: z.ZodSetDef\n  ZodFunction: z.ZodFunctionDef\n  ZodLazy: z.ZodLazyDef\n  ZodLiteral: z.ZodLiteralDef\n  ZodEnum: z.ZodEnumDef\n  ZodEffects: z.ZodEffectsDef\n  ZodNativeEnum: z.ZodNativeEnumDef\n  ZodOptional: z.ZodOptionalDef\n  ZodNullable: z.ZodNullableDef\n  ZodDefault: z.ZodDefaultDef\n  ZodCatch: z.ZodCatchDef\n  ZodPromise: z.ZodPromiseDef\n  ZodBranded: z.ZodBrandedDef<A>\n  ZodPipeline: z.ZodPipelineDef<A, B>\n}\n\nexport interface TypeMap<\n  /* eslint-disable @typescript-eslint/no-unnecessary-type-constraint, @typescript-eslint/no-unused-vars */\n  A extends any = any,\n  B extends any = any,\n  C extends any = any,\n  D extends any = any,\n  E extends any = any\n  /* eslint-enable @typescript-eslint/no-unnecessary-type-constraint, @typescript-eslint/no-unused-vars */\n> extends ZodTypeMap<A, B, C, D, E> {}\n\nexport interface TypeDefMap<\n  /* eslint-disable @typescript-eslint/no-unnecessary-type-constraint, @typescript-eslint/no-unused-vars */\n  A extends any = any,\n  B extends any = any,\n  C extends any = any,\n  D extends any = any,\n  E extends any = any\n  /* eslint-enable @typescript-eslint/no-unnecessary-type-constraint, @typescript-eslint/no-unused-vars */\n> extends ZodTypeDefMap<A, B, C, D, E> {}\n\nexport enum InnerTypes {}\n\nexport type AllTypes = InnerTypes | ZodFirstPartyTypeKind\n\nexport const AllTypes = { ...InnerTypes, ...ZodFirstPartyTypeKind }\n\nexport type AllType = keyof TypeMap\n\nexport interface ModesMap extends Record<AllTypes, string> {\n  [ZodFirstPartyTypeKind.ZodNumber]:\n    | 'slider'\n    | 'rate'\n  [ZodFirstPartyTypeKind.ZodString]:\n    | 'textarea'\n    | 'link'\n    | 'secrets'\n    | 'date'\n    | 'datetime'\n    | 'time'\n    | 'panel'\n  [ZodFirstPartyTypeKind.ZodBoolean]:\n    | 'checkbox'\n  [ZodFirstPartyTypeKind.ZodDate]:\n    | 'datetime'\n    | 'date'\n    | 'time'\n    | 'panel'\n  [ZodFirstPartyTypeKind.ZodUnion]:\n    | 'append'\n    | 'radio'\n    | 'radio-inline'\n    | 'button'\n  [ZodFirstPartyTypeKind.ZodTuple]:\n    | 'range'\n    | 'slider'\n    | 'no-range'\n    | 'no-slider'\n    | 'datetime'\n    | 'date'\n    | 'time'\n    | 'panel'\n}\n","filePath":"file:///node_modules/@types/@zodui/core/type.ts"},{"content":"import type { Schema, ZodTypeAny, ZodTypeDef, ZodUnionOptions } from 'zod'\nimport { ZodFirstPartyTypeKind, ZodUnion } from 'zod'\n\nimport type { AllType, TypeMap } from './type'\n\ntype Cast<A, B> = A extends B ? A : B;\n\ntype Primitive = string | number | boolean | bigint | symbol | undefined | null;\n\nexport type Narrow<T> = Cast<T, unknown[] | [] | (T extends Primitive ? T : never) | ({\n  [K in keyof T]: Narrow<T[K]>\n})>;\n\nexport type Mutable<T> = {\n  -readonly [P in keyof T]: T[P];\n}\n\nexport function getModes(mode: string) {\n  return mode\n    ?.split(' ')\n    ?.filter(s => s !== ' ' && s !== '')\n    ?? []\n}\n\ninterface IsWhatType {\n  <T extends AllType>(\n    s: Schema<any, ZodTypeDef & {\n      typeName?: AllType\n    }, any>,\n    type: T\n  ): s is TypeMap[T]\n  <T extends AllType>(\n    s: ZodTypeDef & {\n      typeName?: AllType\n    },\n    type: T\n  ): s is TypeMap[T]['_def']\n}\n\nexport const isWhatType = ((s: any, type) => (s?._def || s)?.typeName === type) as IsWhatType\n\nexport function isWhatTypes<T extends AllType>(\n  s: Schema<any, ZodTypeDef & {\n    typeName?: AllType\n  }, any>,\n  types: T[]\n): s is TypeMap[T] {\n  return types.includes(s?._def?.typeName as any)\n}\n\nexport function getDefaultValue(s: Schema) {\n  if (isWhatType(s, ZodFirstPartyTypeKind.ZodDefault)) {\n    return s?._def?.defaultValue()\n  }\n  return undefined\n}\n\nexport function containSome(a: string[], b: string[]) {\n  for (const item of a) {\n    if (b.includes(item)) {\n      return true\n    }\n  }\n}\n\nexport function inlineMarkdown(md: string) {\n  return md\n    .replace(/\\[([^\\]]+)]\\(([^)]+)\\)/g, '<a href=\"$2\" target=\"_blank\">$1</a>')\n    .replace(/`([^`]+)`/g, '<code>$1</code>')\n    .replace(/\\*\\*([^*]+)\\*\\*/g, '<strong>$1</strong>')\n    .replace(/\\*([^*]+)\\*/g, '<em>$1</em>')\n    .replace(/~~([^~]+)~~/g, '<del>$1</del>')\n    .replace(/\\n/g, '<br />')\n    .replace(/\\|\\|([^|]+)\\|\\|/g, '<span class=\"spoiler\">$1</span>')\n}\n\nexport function merge<T extends {}, U extends {}>(a: T, b: U): T & U {\n  const target = {} as T & U\n  const aKeys = Object.keys(a) as (keyof T)[]\n  const bKeys = Object.keys(b) as (keyof U)[]\n  for (const key of aKeys) {\n    const aItem = a[key]\n    if (Object.hasOwn(b, key)) {\n      // @ts-ignore\n      const bItem = b[key]\n      if (Array.isArray(aItem) && Array.isArray(bItem)) {\n        target[key] = [...aItem, ...bItem] as any\n        break\n      }\n      if (typeof aItem === 'object' && typeof bItem === 'object') {\n        target[key] = merge(aItem, bItem)\n        break\n      }\n    }\n    target[key] = a[key] as any\n  }\n  for (const key of bKeys) {\n    if (!Object.hasOwn(a, key)) {\n      target[key] = b[key] as any\n    }\n  }\n  return { ...a, ...b }\n}\n\nexport function debounce<T extends (...args: any[]) => any>(fn: T, delay: number) {\n  let timer: any\n  return (...args: any[]) => {\n    clearTimeout(timer)\n    timer = setTimeout(() => {\n      fn(...args)\n    }, delay)\n  }\n}\n\nexport function classnames(...args: (string | undefined | null | false | Record<string, boolean>)[]) {\n  return args\n    .filter(<T>(v: T | boolean): v is T => Boolean(v))\n    .map(arg => {\n      if (typeof arg === 'string') {\n        return arg\n      }\n      return Object.keys(arg).filter(key => arg[key]).join(' ')\n    }).join(' ')\n}\n\nexport const flatUnwrapUnion = <\n  T extends ZodUnionOptions = readonly [ZodTypeAny, ...ZodTypeAny[]]\n>(\n    t: ZodUnion<T>\n  ): Mutable<T> => {\n  return t.options.flatMap((x) => {\n    if (x instanceof ZodUnion) {\n      return flatUnwrapUnion(x)\n    }\n    return x\n  }) as unknown as T\n}\n","filePath":"file:///node_modules/@types/@zodui/core/utils.ts"}];</script><style>.monaco-editor{min-width:412px!important;max-width:100%;height:calc(100% - 50px)}.monaco-editor.resizeable::after{content:' ';background-color:#ccc;position:absolute;top:0;right:0;width:4px;height:100%;cursor:ew-resize;transition:.3s}</style><script type="importmap">{"imports":{"zod":"/zodui/assets/zodui.external-1716232751336.js","zodui":"/zodui/assets/zodui.external-1716232751336.js","@zodui/core/external":"/zodui/assets/zodui.external-1716232751336.js"}}</script><script type="module" crossorigin src="/zodui/assets/play-eb258ea1.js"></script><link rel="modulepreload" crossorigin href="/zodui/assets/theme-switcher-4ee9bded.js"><link rel="modulepreload" crossorigin href="/zodui/assets/react-64d51446.js"><link rel="modulepreload" crossorigin href="/zodui/assets/tdesign-icons-react-1b74273e.js"><link rel="modulepreload" crossorigin href="/zodui/assets/tdesign-react-90877bd8.js"><link rel="modulepreload" crossorigin href="/zodui/assets/comps-lib-tdesign-b131519f.js"><link rel="modulepreload" crossorigin href="/zodui/assets/schema-eval-f25a10fb.js"><link rel="stylesheet" href="/zodui/assets/theme-switcher-0988eae6.css"><link rel="stylesheet" href="/zodui/assets/schema-eval-eac5dbfe.css"><link rel="stylesheet" href="/zodui/assets/comps-lib-tdesign-0d0304e3.css"><link rel="stylesheet" href="/zodui/assets/tdesign-react-4c888f02.css"><link rel="stylesheet" href="/zodui/assets/play-be12528a.css"></head><body><style data-name="header">html[theme-mode=dark] #header{background-color:#31518c}#header{z-index:1;position:absolute;top:0;left:0;display:flex;align-items:center;justify-content:space-between;padding:5px 30px;width:calc(100vw - 60px);height:50px;background-color:#3e67b1;backdrop-filter:blur(6px);transition:.3s;overflow:hidden}#header>.header-left{display:flex;align-items:center;gap:20px}#header>.header-left>a{display:flex;align-items:center;text-decoration:none;transition:.3s}#header>.header-left>.tabs{position:relative;display:flex;gap:20px;height:100%;color:#aaa;font-size:16px}#header>.header-left>.tabs>.active-bar{position:absolute;bottom:-25px;left:0;width:100px;height:5px;background-color:#6f92e3;transition:.3s}#header>.header-left>.tabs>.tab{padding:4px;width:100px;text-align:center;user-select:none;cursor:pointer;color:var(--pr-fr-cr);font-size:16px;font-weight:700;transition:.3s}#header>.header-left>.tabs>.tab.disabled{color:var(--pr-pl-cr);cursor:not-allowed}#header>.header-left>.tabs>.tab:not(.disabled):hover{color:#0648b7!important;background-color:#fffa;border-radius:4px}#header>.header-left>.tabs>.tab>a{color:inherit;text-decoration:none}#header>.header-right{display:flex;gap:5px;user-select:none}#header>.header-right>a{display:flex;align-items:center}#header>.header-right>a:active,#header>.header-right>a:hover{filter:drop-shadow(0 0 8px lightgray)}</style><div id="header"><div class="header-left"><a href="/zodui/"><img src="/zodui/favicon.svg" alt="ZodUI" width="48" height="48"></a><div class="tabs"><div class="active-bar"></div><div class="tab"><a href="/zodui/docs">Docs</a></div><div class="tab disabled">Handbook</div><div class="tab"><a href="/zodui/play">Playground</a></div><div class="tab disabled">Community</div></div></div><div class="header-right"><div class="theme-switcher"><div class="dark-and-light" data-mode="light"><div class="light" data-mode="light"><svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M9.99996 3.15217C10.5252 3.15217 10.951 2.72636 10.951 2.20109C10.951 1.67582 10.5252 1.25 9.99996 1.25C9.47469 1.25 9.04887 1.67582 9.04887 2.20109C9.04887 2.72636 9.47469 3.15217 9.99996 3.15217Z"></path><path fill="currentColor" d="M9.99992 4.29348C6.84829 4.29348 4.2934 6.84838 4.2934 10C4.2934 13.1516 6.84829 15.7065 9.99992 15.7065C13.1515 15.7065 15.7064 13.1516 15.7064 10C15.7064 6.84838 13.1515 4.29348 9.99992 4.29348Z"></path><path fill="currentColor" d="M16.4673 4.4837C16.4673 5.00896 16.0415 5.43478 15.5162 5.43478C14.991 5.43478 14.5652 5.00896 14.5652 4.4837C14.5652 3.95843 14.991 3.53261 15.5162 3.53261C16.0415 3.53261 16.4673 3.95843 16.4673 4.4837Z"></path><path fill="currentColor" d="M17.7989 10.9511C18.3241 10.9511 18.75 10.5253 18.75 10C18.75 9.47474 18.3241 9.04891 17.7989 9.04891C17.2736 9.04891 16.8478 9.47474 16.8478 10C16.8478 10.5253 17.2736 10.9511 17.7989 10.9511Z"></path><path fill="currentColor" d="M16.4673 15.5163C16.4673 16.0416 16.0415 16.4674 15.5162 16.4674C14.991 16.4674 14.5652 16.0416 14.5652 15.5163C14.5652 14.991 14.991 14.5652 15.5162 14.5652C16.0415 14.5652 16.4673 14.991 16.4673 15.5163Z"></path><path fill="currentColor" d="M9.99996 18.75C10.5252 18.75 10.951 18.3242 10.951 17.7989C10.951 17.2736 10.5252 16.8478 9.99996 16.8478C9.47469 16.8478 9.04887 17.2736 9.04887 17.7989C9.04887 18.3242 9.47469 18.75 9.99996 18.75Z"></path><path fill="currentColor" d="M5.43469 15.5163C5.43469 16.0416 5.00887 16.4674 4.4836 16.4674C3.95833 16.4674 3.53252 16.0416 3.53252 15.5163C3.53252 14.991 3.95833 14.5652 4.4836 14.5652C5.00887 14.5652 5.43469 14.991 5.43469 15.5163Z"></path><path fill="currentColor" d="M2.20096 10.9511C2.72623 10.9511 3.15205 10.5253 3.15205 10C3.15205 9.47474 2.72623 9.04891 2.20096 9.04891C1.67569 9.04891 1.24988 9.47474 1.24988 10C1.24988 10.5253 1.67569 10.9511 2.20096 10.9511Z"></path><path fill="currentColor" d="M5.43469 4.4837C5.43469 5.00896 5.00887 5.43478 4.4836 5.43478C3.95833 5.43478 3.53252 5.00896 3.53252 4.4837C3.53252 3.95843 3.95833 3.53261 4.4836 3.53261C5.00887 3.53261 5.43469 3.95843 5.43469 4.4837Z"></path></svg></div><div class="dark" data-mode="dark"><svg width="20" height="20" viewBox="0 0 20 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M9.99993 3.12494C6.20294 3.12494 3.12488 6.203 3.12488 10C3.12488 13.797 6.20294 16.8751 9.99993 16.8751C13.7969 16.8751 16.875 13.797 16.875 10C16.875 9.52352 16.8264 9.0577 16.7337 8.6075C16.6752 8.32295 16.4282 8.11628 16.1378 8.10872C15.8474 8.10117 15.5901 8.29473 15.5168 8.57585C15.1411 10.0167 13.8302 11.0795 12.2727 11.0795C10.4212 11.0795 8.92039 9.57869 8.92039 7.72726C8.92039 6.16969 9.98319 4.85879 11.4241 4.48312C11.7052 4.40983 11.8988 4.15249 11.8912 3.86207C11.8836 3.57165 11.677 3.32473 11.3924 3.26616C10.9422 3.1735 10.4764 3.12494 9.99993 3.12494Z"></path></svg></div></div><div class="auto" data-mode="auto" title="auto detect by system" style="transform:rotate(45deg)"><svg width="10" height="20" viewBox="0 0 10 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M9.99996 3.15217C10.5252 3.15217 10.951 2.72636 10.951 2.20109C10.951 1.67582 10.5252 1.25 9.99996 1.25C9.47469 1.25 9.04887 1.67582 9.04887 2.20109C9.04887 2.72636 9.47469 3.15217 9.99996 3.15217Z"></path><path fill="currentColor" d="M9.99992 4.29348C6.84829 4.29348 4.2934 6.84838 4.2934 10C4.2934 13.1516 6.84829 15.7065 9.99992 15.7065C13.1515 15.7065 15.7064 13.1516 15.7064 10C15.7064 6.84838 13.1515 4.29348 9.99992 4.29348Z"></path><path fill="currentColor" d="M16.4673 4.4837C16.4673 5.00896 16.0415 5.43478 15.5162 5.43478C14.991 5.43478 14.5652 5.00896 14.5652 4.4837C14.5652 3.95843 14.991 3.53261 15.5162 3.53261C16.0415 3.53261 16.4673 3.95843 16.4673 4.4837Z"></path><path fill="currentColor" d="M17.7989 10.9511C18.3241 10.9511 18.75 10.5253 18.75 10C18.75 9.47474 18.3241 9.04891 17.7989 9.04891C17.2736 9.04891 16.8478 9.47474 16.8478 10C16.8478 10.5253 17.2736 10.9511 17.7989 10.9511Z"></path><path fill="currentColor" d="M16.4673 15.5163C16.4673 16.0416 16.0415 16.4674 15.5162 16.4674C14.991 16.4674 14.5652 16.0416 14.5652 15.5163C14.5652 14.991 14.991 14.5652 15.5162 14.5652C16.0415 14.5652 16.4673 14.991 16.4673 15.5163Z"></path><path fill="currentColor" d="M9.99996 18.75C10.5252 18.75 10.951 18.3242 10.951 17.7989C10.951 17.2736 10.5252 16.8478 9.99996 16.8478C9.47469 16.8478 9.04887 17.2736 9.04887 17.7989C9.04887 18.3242 9.47469 18.75 9.99996 18.75Z"></path><path fill="currentColor" d="M5.43469 15.5163C5.43469 16.0416 5.00887 16.4674 4.4836 16.4674C3.95833 16.4674 3.53252 16.0416 3.53252 15.5163C3.53252 14.991 3.95833 14.5652 4.4836 14.5652C5.00887 14.5652 5.43469 14.991 5.43469 15.5163Z"></path><path fill="currentColor" d="M2.20096 10.9511C2.72623 10.9511 3.15205 10.5253 3.15205 10C3.15205 9.47474 2.72623 9.04891 2.20096 9.04891C1.67569 9.04891 1.24988 9.47474 1.24988 10C1.24988 10.5253 1.67569 10.9511 2.20096 10.9511Z"></path><path fill="currentColor" d="M5.43469 4.4837C5.43469 5.00896 5.00887 5.43478 4.4836 5.43478C3.95833 5.43478 3.53252 5.00896 3.53252 4.4837C3.53252 3.95843 3.95833 3.53261 4.4836 3.53261C5.00887 3.53261 5.43469 3.95843 5.43469 4.4837Z"></path></svg> <svg width="10" height="20" viewBox="10 0 10 20" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill="currentColor" d="M9.99993 3.12494C6.20294 3.12494 3.12488 6.203 3.12488 10C3.12488 13.797 6.20294 16.8751 9.99993 16.8751C13.7969 16.8751 16.875 13.797 16.875 10C16.875 9.52352 16.8264 9.0577 16.7337 8.6075C16.6752 8.32295 16.4282 8.11628 16.1378 8.10872C15.8474 8.10117 15.5901 8.29473 15.5168 8.57585C15.1411 10.0167 13.8302 11.0795 12.2727 11.0795C10.4212 11.0795 8.92039 9.57869 8.92039 7.72726C8.92039 6.16969 9.98319 4.85879 11.4241 4.48312C11.7052 4.40983 11.8988 4.15249 11.8912 3.86207C11.8836 3.57165 11.677 3.32473 11.3924 3.26616C10.9422 3.1735 10.4764 3.12494 9.99993 3.12494Z"></path></svg></div></div><a href="https://github.com/zodui/zodui" target="_blank"><img src="https://github.githubassets.com/favicons/favicon.svg" alt="GitHub ZodUI Repsitory" width="20" height="20"></a></div></div><script data-name="tab-controller">window.TABS = [{"title":"Docs","filename":"docs","template":"src/docs.html","href":"/zodui/docs"},{"title":"Handbook","filename":"handbook","template":"src/handbook.html","disabled":true,"href":"/zodui/handbook"},{"title":"Playground","filename":"play","template":"src/play.html","href":"/zodui/play"},{"title":"Community","filename":"docs","template":"src/community.html","disabled":true,"href":"/zodui/docs"}]

  ;window.addEventListener('load', () => {
    /** @type {HTMLDivElement} */
    const activeBar = document.querySelector('#header .tabs .active-bar')
    const index = window.TABS.findIndex(t => t.href === window.location.pathname)
    if (index > -1) {
      activeBar.style.bottom = '-20px'
      activeBar.style.left = `${index * 130}px`
    }
  })</script><main class="loading"><div class="code-editor"><div class="menu"><span class="item material-icons settings">settings</span> <span class="item material-icons share">share</span> <span class="item material-icons right fold" style="transform:rotate(180deg)">double_arrow</span></div><div data-key="playground" class="monaco-editor resizeable" data-by-hash="true"></div><script type="importmap" data-key="playground">{
    "imports": {
    }
  }</script><div class="menu-page"><div class="settings"><div class="schema-eval-container" data-key="settings" data-code="import z from &#39;zod&#39;
export default z.object({
  mode: z
    .union([
      z
        .literal(&#39;full&#39;)
        .label(&#39;Full&#39;),
      z
        .literal(&#39;card&#39;)
        .label(&#39;Card&#39;),
    ])
    .default(&#39;card&#39;)
    .label(&#39;Mode&#39;)
    .describe(&#39;Controls the style of the form&#39;),
  width: z
    .tuple([
      z
        .number()
        .default(60)
        .mode(&#39;split&#39;)
        .label(&#39;Value&#39;),
      z
        .union([
          z.literal(&#39;%&#39;).label(&#39;percent&#39;),
          z.literal(&#39;px&#39;).label(&#39;pixel&#39;),
        ])
        .default(&#39;%&#39;)
    ])
    .describe(&#39;Controls the width of the form&#39;)
    .mode(&#39;wrap&#39;),
})"><div class="empty">loading...</div></div></div></div></div><div class="schema-eval-container" data-key="playground"><div class="empty">loading...</div></div></main></body></html>